{"ast":null,"code":"var through = require('through');\n\nvar bz2 = require('./lib/bzip2');\n\nvar bitIterator = require('./lib/bit_iterator');\n\nmodule.exports = unbzip2Stream;\n\nfunction unbzip2Stream() {\n  var bufferQueue = [];\n  var hasBytes = 0;\n  var blockSize = 0;\n  var broken = false;\n  var done = false;\n  var bitReader = null;\n  var streamCRC = null;\n\n  function decompressBlock(push) {\n    if (!blockSize) {\n      blockSize = bz2.header(bitReader); //console.error(\"got header of\", blockSize);\n\n      streamCRC = 0;\n      return true;\n    } else {\n      var bufsize = 100000 * blockSize;\n      var buf = new Int32Array(bufsize);\n      var chunk = [];\n\n      var f = function (b) {\n        chunk.push(b);\n      };\n\n      streamCRC = bz2.decompress(bitReader, f, buf, bufsize, streamCRC);\n\n      if (streamCRC === null) {\n        // reset for next bzip2 header\n        blockSize = 0;\n        return false;\n      } else {\n        //console.error('decompressed', chunk.length,'bytes');\n        push(Buffer.from(chunk));\n        return true;\n      }\n    }\n  }\n\n  var outlength = 0;\n\n  function decompressAndQueue(stream) {\n    if (broken) return;\n\n    try {\n      return decompressBlock(function (d) {\n        stream.queue(d);\n\n        if (d !== null) {\n          //console.error('write at', outlength.toString(16));\n          outlength += d.length;\n        } else {//console.error('written EOS');\n        }\n      });\n    } catch (e) {\n      //console.error(e);\n      stream.emit('error', e);\n      broken = true;\n      return false;\n    }\n  }\n\n  return through(function write(data) {\n    //console.error('received', data.length,'bytes in', typeof data);\n    bufferQueue.push(data);\n    hasBytes += data.length;\n\n    if (bitReader === null) {\n      bitReader = bitIterator(function () {\n        return bufferQueue.shift();\n      });\n    }\n\n    while (!broken && hasBytes - bitReader.bytesRead + 1 >= (25000 + 100000 * blockSize || 4)) {\n      //console.error('decompressing with', hasBytes - bitReader.bytesRead + 1, 'bytes in buffer');\n      decompressAndQueue(this);\n    }\n  }, function end(x) {\n    //console.error(x,'last compressing with', hasBytes, 'bytes in buffer');\n    while (!broken && bitReader && hasBytes > bitReader.bytesRead) {\n      decompressAndQueue(this);\n    }\n\n    if (!broken) {\n      if (streamCRC !== null) this.emit('error', new Error(\"input stream ended prematurely\"));\n      this.queue(null);\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/Sajjad Brohi/JavaScript Projects/RESTful API/packages/client/node_modules/unbzip2-stream/index.js"],"names":["through","require","bz2","bitIterator","module","exports","unbzip2Stream","bufferQueue","hasBytes","blockSize","broken","done","bitReader","streamCRC","decompressBlock","push","header","bufsize","buf","Int32Array","chunk","f","b","decompress","Buffer","from","outlength","decompressAndQueue","stream","d","queue","length","e","emit","write","data","shift","bytesRead","end","x","Error"],"mappings":"AAAA,IAAIA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAArB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,aAAD,CAAjB;;AACA,IAAIE,WAAW,GAAGF,OAAO,CAAC,oBAAD,CAAzB;;AAEAG,MAAM,CAACC,OAAP,GAAiBC,aAAjB;;AAEA,SAASA,aAAT,GAAyB;AACrB,MAAIC,WAAW,GAAG,EAAlB;AACA,MAAIC,QAAQ,GAAG,CAAf;AACA,MAAIC,SAAS,GAAG,CAAhB;AACA,MAAIC,MAAM,GAAG,KAAb;AACA,MAAIC,IAAI,GAAG,KAAX;AACA,MAAIC,SAAS,GAAG,IAAhB;AACA,MAAIC,SAAS,GAAG,IAAhB;;AAEA,WAASC,eAAT,CAAyBC,IAAzB,EAA8B;AAC1B,QAAG,CAACN,SAAJ,EAAc;AACVA,MAAAA,SAAS,GAAGP,GAAG,CAACc,MAAJ,CAAWJ,SAAX,CAAZ,CADU,CAEV;;AACAC,MAAAA,SAAS,GAAG,CAAZ;AACA,aAAO,IAAP;AACH,KALD,MAKK;AACD,UAAII,OAAO,GAAG,SAASR,SAAvB;AACA,UAAIS,GAAG,GAAG,IAAIC,UAAJ,CAAeF,OAAf,CAAV;AAEA,UAAIG,KAAK,GAAG,EAAZ;;AACA,UAAIC,CAAC,GAAG,UAASC,CAAT,EAAY;AAChBF,QAAAA,KAAK,CAACL,IAAN,CAAWO,CAAX;AACH,OAFD;;AAIAT,MAAAA,SAAS,GAAGX,GAAG,CAACqB,UAAJ,CAAeX,SAAf,EAA0BS,CAA1B,EAA6BH,GAA7B,EAAkCD,OAAlC,EAA2CJ,SAA3C,CAAZ;;AACA,UAAIA,SAAS,KAAK,IAAlB,EAAwB;AACpB;AACAJ,QAAAA,SAAS,GAAG,CAAZ;AACA,eAAO,KAAP;AACH,OAJD,MAIK;AACD;AACAM,QAAAA,IAAI,CAACS,MAAM,CAACC,IAAP,CAAYL,KAAZ,CAAD,CAAJ;AACA,eAAO,IAAP;AACH;AACJ;AACJ;;AAED,MAAIM,SAAS,GAAG,CAAhB;;AACA,WAASC,kBAAT,CAA4BC,MAA5B,EAAoC;AAChC,QAAIlB,MAAJ,EAAY;;AACZ,QAAI;AACA,aAAOI,eAAe,CAAC,UAASe,CAAT,EAAY;AAC/BD,QAAAA,MAAM,CAACE,KAAP,CAAaD,CAAb;;AACA,YAAIA,CAAC,KAAK,IAAV,EAAgB;AACZ;AACAH,UAAAA,SAAS,IAAIG,CAAC,CAACE,MAAf;AACH,SAHD,MAGO,CACH;AACH;AACJ,OARqB,CAAtB;AASH,KAVD,CAUE,OAAMC,CAAN,EAAS;AACP;AACAJ,MAAAA,MAAM,CAACK,IAAP,CAAY,OAAZ,EAAqBD,CAArB;AACAtB,MAAAA,MAAM,GAAG,IAAT;AACA,aAAO,KAAP;AACH;AACJ;;AAED,SAAOV,OAAO,CACV,SAASkC,KAAT,CAAeC,IAAf,EAAqB;AACjB;AACA5B,IAAAA,WAAW,CAACQ,IAAZ,CAAiBoB,IAAjB;AACA3B,IAAAA,QAAQ,IAAI2B,IAAI,CAACJ,MAAjB;;AACA,QAAInB,SAAS,KAAK,IAAlB,EAAwB;AACpBA,MAAAA,SAAS,GAAGT,WAAW,CAAC,YAAW;AAC/B,eAAOI,WAAW,CAAC6B,KAAZ,EAAP;AACH,OAFsB,CAAvB;AAGH;;AACD,WAAO,CAAC1B,MAAD,IAAWF,QAAQ,GAAGI,SAAS,CAACyB,SAArB,GAAiC,CAAjC,KAAwC,QAAQ,SAAS5B,SAAlB,IAAgC,CAAvE,CAAlB,EAA4F;AACxF;AACAkB,MAAAA,kBAAkB,CAAC,IAAD,CAAlB;AACH;AACJ,GAdS,EAeV,SAASW,GAAT,CAAaC,CAAb,EAAgB;AACZ;AACA,WAAO,CAAC7B,MAAD,IAAWE,SAAX,IAAwBJ,QAAQ,GAAGI,SAAS,CAACyB,SAApD,EAA8D;AAC1DV,MAAAA,kBAAkB,CAAC,IAAD,CAAlB;AACH;;AACD,QAAI,CAACjB,MAAL,EAAa;AACT,UAAIG,SAAS,KAAK,IAAlB,EACI,KAAKoB,IAAL,CAAU,OAAV,EAAmB,IAAIO,KAAJ,CAAU,gCAAV,CAAnB;AACJ,WAAKV,KAAL,CAAW,IAAX;AACH;AACJ,GAzBS,CAAd;AA2BH","sourcesContent":["var through = require('through');\nvar bz2 = require('./lib/bzip2');\nvar bitIterator = require('./lib/bit_iterator');\n\nmodule.exports = unbzip2Stream;\n\nfunction unbzip2Stream() {\n    var bufferQueue = [];\n    var hasBytes = 0;\n    var blockSize = 0;\n    var broken = false;\n    var done = false;\n    var bitReader = null;\n    var streamCRC = null;\n\n    function decompressBlock(push){\n        if(!blockSize){\n            blockSize = bz2.header(bitReader);\n            //console.error(\"got header of\", blockSize);\n            streamCRC = 0;\n            return true;\n        }else{\n            var bufsize = 100000 * blockSize;\n            var buf = new Int32Array(bufsize);\n            \n            var chunk = [];\n            var f = function(b) {\n                chunk.push(b);\n            };\n\n            streamCRC = bz2.decompress(bitReader, f, buf, bufsize, streamCRC);\n            if (streamCRC === null) {\n                // reset for next bzip2 header\n                blockSize = 0;\n                return false;\n            }else{\n                //console.error('decompressed', chunk.length,'bytes');\n                push(Buffer.from(chunk));\n                return true;\n            }\n        }\n    }\n\n    var outlength = 0;\n    function decompressAndQueue(stream) {\n        if (broken) return;\n        try {\n            return decompressBlock(function(d) {\n                stream.queue(d);\n                if (d !== null) {\n                    //console.error('write at', outlength.toString(16));\n                    outlength += d.length;\n                } else {\n                    //console.error('written EOS');\n                }\n            });\n        } catch(e) {\n            //console.error(e);\n            stream.emit('error', e);\n            broken = true;\n            return false;\n        }\n    }\n\n    return through(\n        function write(data) {\n            //console.error('received', data.length,'bytes in', typeof data);\n            bufferQueue.push(data);\n            hasBytes += data.length;\n            if (bitReader === null) {\n                bitReader = bitIterator(function() {\n                    return bufferQueue.shift();\n                });\n            }\n            while (!broken && hasBytes - bitReader.bytesRead + 1 >= ((25000 + 100000 * blockSize) || 4)){\n                //console.error('decompressing with', hasBytes - bitReader.bytesRead + 1, 'bytes in buffer');\n                decompressAndQueue(this);\n            }\n        },\n        function end(x) {\n            //console.error(x,'last compressing with', hasBytes, 'bytes in buffer');\n            while (!broken && bitReader && hasBytes > bitReader.bytesRead){\n                decompressAndQueue(this);\n            }\n            if (!broken) {\n                if (streamCRC !== null)\n                    this.emit('error', new Error(\"input stream ended prematurely\"));\n                this.queue(null);\n            }\n        }\n    );\n}\n\n"]},"metadata":{},"sourceType":"script"}