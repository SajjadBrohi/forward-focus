{"ast":null,"code":"var BITMASK = [0, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF]; // returns a function that reads bits.\n// takes a buffer iterator as input\n\nmodule.exports = function bitIterator(nextBuffer) {\n  var bit = 0,\n      byte = 0;\n  var bytes = nextBuffer();\n\n  var f = function (n) {\n    if (n === null && bit != 0) {\n      // align to byte boundary\n      bit = 0;\n      byte++;\n      return;\n    }\n\n    var result = 0;\n\n    while (n > 0) {\n      if (byte >= bytes.length) {\n        byte = 0;\n        bytes = nextBuffer();\n      }\n\n      var left = 8 - bit;\n      if (bit === 0 && n > 0) f.bytesRead++;\n\n      if (n >= left) {\n        result <<= left;\n        result |= BITMASK[left] & bytes[byte++];\n        bit = 0;\n        n -= left;\n      } else {\n        result <<= n;\n        result |= (bytes[byte] & BITMASK[n] << 8 - n - bit) >> 8 - n - bit;\n        bit += n;\n        n = 0;\n      }\n    }\n\n    return result;\n  };\n\n  f.bytesRead = 0;\n  return f;\n};","map":{"version":3,"sources":["C:/Users/Sajjad Brohi/JavaScript Projects/RESTful API/packages/client/node_modules/unbzip2-stream/lib/bit_iterator.js"],"names":["BITMASK","module","exports","bitIterator","nextBuffer","bit","byte","bytes","f","n","result","length","left","bytesRead"],"mappings":"AAAA,IAAIA,OAAO,GAAG,CAAC,CAAD,EAAI,IAAJ,EAAU,IAAV,EAAgB,IAAhB,EAAsB,IAAtB,EAA4B,IAA5B,EAAkC,IAAlC,EAAwC,IAAxC,EAA8C,IAA9C,CAAd,C,CAEA;AACA;;AACAC,MAAM,CAACC,OAAP,GAAiB,SAASC,WAAT,CAAqBC,UAArB,EAAiC;AAC9C,MAAIC,GAAG,GAAG,CAAV;AAAA,MAAaC,IAAI,GAAG,CAApB;AACA,MAAIC,KAAK,GAAGH,UAAU,EAAtB;;AACA,MAAII,CAAC,GAAG,UAASC,CAAT,EAAY;AAChB,QAAIA,CAAC,KAAK,IAAN,IAAcJ,GAAG,IAAI,CAAzB,EAA4B;AAAG;AAC3BA,MAAAA,GAAG,GAAG,CAAN;AACAC,MAAAA,IAAI;AACJ;AACH;;AACD,QAAII,MAAM,GAAG,CAAb;;AACA,WAAMD,CAAC,GAAG,CAAV,EAAa;AACT,UAAIH,IAAI,IAAIC,KAAK,CAACI,MAAlB,EAA0B;AACtBL,QAAAA,IAAI,GAAG,CAAP;AACAC,QAAAA,KAAK,GAAGH,UAAU,EAAlB;AACH;;AACD,UAAIQ,IAAI,GAAG,IAAIP,GAAf;AACA,UAAIA,GAAG,KAAK,CAAR,IAAaI,CAAC,GAAG,CAArB,EACID,CAAC,CAACK,SAAF;;AACJ,UAAIJ,CAAC,IAAIG,IAAT,EAAe;AACXF,QAAAA,MAAM,KAAKE,IAAX;AACAF,QAAAA,MAAM,IAAKV,OAAO,CAACY,IAAD,CAAP,GAAgBL,KAAK,CAACD,IAAI,EAAL,CAAhC;AACAD,QAAAA,GAAG,GAAG,CAAN;AACAI,QAAAA,CAAC,IAAIG,IAAL;AACH,OALD,MAKO;AACHF,QAAAA,MAAM,KAAKD,CAAX;AACAC,QAAAA,MAAM,IAAK,CAACH,KAAK,CAACD,IAAD,CAAL,GAAeN,OAAO,CAACS,CAAD,CAAP,IAAe,IAAIA,CAAJ,GAAQJ,GAAvC,KAAkD,IAAII,CAAJ,GAAQJ,GAArE;AACAA,QAAAA,GAAG,IAAII,CAAP;AACAA,QAAAA,CAAC,GAAG,CAAJ;AACH;AACJ;;AACD,WAAOC,MAAP;AACH,GA5BD;;AA6BAF,EAAAA,CAAC,CAACK,SAAF,GAAc,CAAd;AACA,SAAOL,CAAP;AACH,CAlCD","sourcesContent":["var BITMASK = [0, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF];\n\n// returns a function that reads bits.\n// takes a buffer iterator as input\nmodule.exports = function bitIterator(nextBuffer) {\n    var bit = 0, byte = 0;\n    var bytes = nextBuffer();\n    var f = function(n) {\n        if (n === null && bit != 0) {  // align to byte boundary\n            bit = 0\n            byte++;\n            return;\n        }\n        var result = 0;\n        while(n > 0) {\n            if (byte >= bytes.length) {\n                byte = 0;\n                bytes = nextBuffer();\n            }\n            var left = 8 - bit;\n            if (bit === 0 && n > 0)\n                f.bytesRead++;\n            if (n >= left) {\n                result <<= left;\n                result |= (BITMASK[left] & bytes[byte++]);\n                bit = 0;\n                n -= left;\n            } else {\n                result <<= n;\n                result |= ((bytes[byte] & (BITMASK[n] << (8 - n - bit))) >> (8 - n - bit));\n                bit += n;\n                n = 0;\n            }\n        }\n        return result;\n    };\n    f.bytesRead = 0;\n    return f;\n};\n"]},"metadata":{},"sourceType":"script"}