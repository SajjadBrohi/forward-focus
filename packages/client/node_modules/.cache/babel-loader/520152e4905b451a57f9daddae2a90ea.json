{"ast":null,"code":"const debug = require('debug')('extract-zip'); // eslint-disable-next-line node/no-unsupported-features/node-builtins\n\n\nconst {\n  createWriteStream,\n  promises: fs\n} = require('fs');\n\nconst getStream = require('get-stream');\n\nconst path = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst stream = require('stream');\n\nconst yauzl = require('yauzl');\n\nconst openZip = promisify(yauzl.open);\nconst pipeline = promisify(stream.pipeline);\n\nclass Extractor {\n  constructor(zipPath, opts) {\n    this.zipPath = zipPath;\n    this.opts = opts;\n  }\n\n  async extract() {\n    debug('opening', this.zipPath, 'with opts', this.opts);\n    this.zipfile = await openZip(this.zipPath, {\n      lazyEntries: true\n    });\n    this.canceled = false;\n    return new Promise((resolve, reject) => {\n      this.zipfile.on('error', err => {\n        this.canceled = true;\n        reject(err);\n      });\n      this.zipfile.readEntry();\n      this.zipfile.on('close', () => {\n        if (!this.canceled) {\n          debug('zip extraction complete');\n          resolve();\n        }\n      });\n      this.zipfile.on('entry', async entry => {\n        /* istanbul ignore if */\n        if (this.canceled) {\n          debug('skipping entry', entry.fileName, {\n            cancelled: this.canceled\n          });\n          return;\n        }\n\n        debug('zipfile entry', entry.fileName);\n\n        if (entry.fileName.startsWith('__MACOSX/')) {\n          this.zipfile.readEntry();\n          return;\n        }\n\n        const destDir = path.dirname(path.join(this.opts.dir, entry.fileName));\n\n        try {\n          await fs.mkdir(destDir, {\n            recursive: true\n          });\n          const canonicalDestDir = await fs.realpath(destDir);\n          const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir);\n\n          if (relativeDestDir.split(path.sep).includes('..')) {\n            throw new Error(`Out of bound path \"${canonicalDestDir}\" found while processing file ${entry.fileName}`);\n          }\n\n          await this.extractEntry(entry);\n          debug('finished processing', entry.fileName);\n          this.zipfile.readEntry();\n        } catch (err) {\n          this.canceled = true;\n          this.zipfile.close();\n          reject(err);\n        }\n      });\n    });\n  }\n\n  async extractEntry(entry) {\n    /* istanbul ignore if */\n    if (this.canceled) {\n      debug('skipping entry extraction', entry.fileName, {\n        cancelled: this.canceled\n      });\n      return;\n    }\n\n    if (this.opts.onEntry) {\n      this.opts.onEntry(entry, this.zipfile);\n    }\n\n    const dest = path.join(this.opts.dir, entry.fileName); // convert external file attr int into a fs stat mode int\n\n    const mode = entry.externalFileAttributes >> 16 & 0xFFFF; // check if it's a symlink or dir (using stat mode constants)\n\n    const IFMT = 61440;\n    const IFDIR = 16384;\n    const IFLNK = 40960;\n    const symlink = (mode & IFMT) === IFLNK;\n    let isDir = (mode & IFMT) === IFDIR; // Failsafe, borrowed from jsZip\n\n    if (!isDir && entry.fileName.endsWith('/')) {\n      isDir = true;\n    } // check for windows weird way of specifying a directory\n    // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566\n\n\n    const madeBy = entry.versionMadeBy >> 8;\n    if (!isDir) isDir = madeBy === 0 && entry.externalFileAttributes === 16;\n    debug('extracting entry', {\n      filename: entry.fileName,\n      isDir: isDir,\n      isSymlink: symlink\n    });\n    const procMode = this.getExtractedMode(mode, isDir) & 0o777; // always ensure folders are created\n\n    const destDir = isDir ? dest : path.dirname(dest);\n    const mkdirOptions = {\n      recursive: true\n    };\n\n    if (isDir) {\n      mkdirOptions.mode = procMode;\n    }\n\n    debug('mkdir', {\n      dir: destDir,\n      ...mkdirOptions\n    });\n    await fs.mkdir(destDir, mkdirOptions);\n    if (isDir) return;\n    debug('opening read stream', dest);\n    const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);\n\n    if (symlink) {\n      const link = await getStream(readStream);\n      debug('creating symlink', link, dest);\n      await fs.symlink(link, dest);\n    } else {\n      await pipeline(readStream, createWriteStream(dest, {\n        mode: procMode\n      }));\n    }\n  }\n\n  getExtractedMode(entryMode, isDir) {\n    let mode = entryMode; // Set defaults, if necessary\n\n    if (mode === 0) {\n      if (isDir) {\n        if (this.opts.defaultDirMode) {\n          mode = parseInt(this.opts.defaultDirMode, 10);\n        }\n\n        if (!mode) {\n          mode = 0o755;\n        }\n      } else {\n        if (this.opts.defaultFileMode) {\n          mode = parseInt(this.opts.defaultFileMode, 10);\n        }\n\n        if (!mode) {\n          mode = 0o644;\n        }\n      }\n    }\n\n    return mode;\n  }\n\n}\n\nmodule.exports = async function (zipPath, opts) {\n  debug('creating target directory', opts.dir);\n\n  if (!path.isAbsolute(opts.dir)) {\n    throw new Error('Target directory is expected to be absolute');\n  }\n\n  await fs.mkdir(opts.dir, {\n    recursive: true\n  });\n  opts.dir = await fs.realpath(opts.dir);\n  return new Extractor(zipPath, opts).extract();\n};","map":{"version":3,"sources":["C:/Users/Sajjad Brohi/JavaScript Projects/RESTful API/packages/client/node_modules/extract-zip/index.js"],"names":["debug","require","createWriteStream","promises","fs","getStream","path","promisify","stream","yauzl","openZip","open","pipeline","Extractor","constructor","zipPath","opts","extract","zipfile","lazyEntries","canceled","Promise","resolve","reject","on","err","readEntry","entry","fileName","cancelled","startsWith","destDir","dirname","join","dir","mkdir","recursive","canonicalDestDir","realpath","relativeDestDir","relative","split","sep","includes","Error","extractEntry","close","onEntry","dest","mode","externalFileAttributes","IFMT","IFDIR","IFLNK","symlink","isDir","endsWith","madeBy","versionMadeBy","filename","isSymlink","procMode","getExtractedMode","mkdirOptions","readStream","openReadStream","bind","link","entryMode","defaultDirMode","parseInt","defaultFileMode","module","exports","isAbsolute"],"mappings":"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","sourcesContent":["const debug = require('debug')('extract-zip')\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nconst { createWriteStream, promises: fs } = require('fs')\nconst getStream = require('get-stream')\nconst path = require('path')\nconst { promisify } = require('util')\nconst stream = require('stream')\nconst yauzl = require('yauzl')\n\nconst openZip = promisify(yauzl.open)\nconst pipeline = promisify(stream.pipeline)\n\nclass Extractor {\n  constructor (zipPath, opts) {\n    this.zipPath = zipPath\n    this.opts = opts\n  }\n\n  async extract () {\n    debug('opening', this.zipPath, 'with opts', this.opts)\n\n    this.zipfile = await openZip(this.zipPath, { lazyEntries: true })\n    this.canceled = false\n\n    return new Promise((resolve, reject) => {\n      this.zipfile.on('error', err => {\n        this.canceled = true\n        reject(err)\n      })\n      this.zipfile.readEntry()\n\n      this.zipfile.on('close', () => {\n        if (!this.canceled) {\n          debug('zip extraction complete')\n          resolve()\n        }\n      })\n\n      this.zipfile.on('entry', async entry => {\n        /* istanbul ignore if */\n        if (this.canceled) {\n          debug('skipping entry', entry.fileName, { cancelled: this.canceled })\n          return\n        }\n\n        debug('zipfile entry', entry.fileName)\n\n        if (entry.fileName.startsWith('__MACOSX/')) {\n          this.zipfile.readEntry()\n          return\n        }\n\n        const destDir = path.dirname(path.join(this.opts.dir, entry.fileName))\n\n        try {\n          await fs.mkdir(destDir, { recursive: true })\n\n          const canonicalDestDir = await fs.realpath(destDir)\n          const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir)\n\n          if (relativeDestDir.split(path.sep).includes('..')) {\n            throw new Error(`Out of bound path \"${canonicalDestDir}\" found while processing file ${entry.fileName}`)\n          }\n\n          await this.extractEntry(entry)\n          debug('finished processing', entry.fileName)\n          this.zipfile.readEntry()\n        } catch (err) {\n          this.canceled = true\n          this.zipfile.close()\n          reject(err)\n        }\n      })\n    })\n  }\n\n  async extractEntry (entry) {\n    /* istanbul ignore if */\n    if (this.canceled) {\n      debug('skipping entry extraction', entry.fileName, { cancelled: this.canceled })\n      return\n    }\n\n    if (this.opts.onEntry) {\n      this.opts.onEntry(entry, this.zipfile)\n    }\n\n    const dest = path.join(this.opts.dir, entry.fileName)\n\n    // convert external file attr int into a fs stat mode int\n    const mode = (entry.externalFileAttributes >> 16) & 0xFFFF\n    // check if it's a symlink or dir (using stat mode constants)\n    const IFMT = 61440\n    const IFDIR = 16384\n    const IFLNK = 40960\n    const symlink = (mode & IFMT) === IFLNK\n    let isDir = (mode & IFMT) === IFDIR\n\n    // Failsafe, borrowed from jsZip\n    if (!isDir && entry.fileName.endsWith('/')) {\n      isDir = true\n    }\n\n    // check for windows weird way of specifying a directory\n    // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566\n    const madeBy = entry.versionMadeBy >> 8\n    if (!isDir) isDir = (madeBy === 0 && entry.externalFileAttributes === 16)\n\n    debug('extracting entry', { filename: entry.fileName, isDir: isDir, isSymlink: symlink })\n\n    const procMode = this.getExtractedMode(mode, isDir) & 0o777\n\n    // always ensure folders are created\n    const destDir = isDir ? dest : path.dirname(dest)\n\n    const mkdirOptions = { recursive: true }\n    if (isDir) {\n      mkdirOptions.mode = procMode\n    }\n    debug('mkdir', { dir: destDir, ...mkdirOptions })\n    await fs.mkdir(destDir, mkdirOptions)\n    if (isDir) return\n\n    debug('opening read stream', dest)\n    const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry)\n\n    if (symlink) {\n      const link = await getStream(readStream)\n      debug('creating symlink', link, dest)\n      await fs.symlink(link, dest)\n    } else {\n      await pipeline(readStream, createWriteStream(dest, { mode: procMode }))\n    }\n  }\n\n  getExtractedMode (entryMode, isDir) {\n    let mode = entryMode\n    // Set defaults, if necessary\n    if (mode === 0) {\n      if (isDir) {\n        if (this.opts.defaultDirMode) {\n          mode = parseInt(this.opts.defaultDirMode, 10)\n        }\n\n        if (!mode) {\n          mode = 0o755\n        }\n      } else {\n        if (this.opts.defaultFileMode) {\n          mode = parseInt(this.opts.defaultFileMode, 10)\n        }\n\n        if (!mode) {\n          mode = 0o644\n        }\n      }\n    }\n\n    return mode\n  }\n}\n\nmodule.exports = async function (zipPath, opts) {\n  debug('creating target directory', opts.dir)\n\n  if (!path.isAbsolute(opts.dir)) {\n    throw new Error('Target directory is expected to be absolute')\n  }\n\n  await fs.mkdir(opts.dir, { recursive: true })\n  opts.dir = await fs.realpath(opts.dir)\n  return new Extractor(zipPath, opts).extract()\n}\n"]},"metadata":{},"sourceType":"script"}