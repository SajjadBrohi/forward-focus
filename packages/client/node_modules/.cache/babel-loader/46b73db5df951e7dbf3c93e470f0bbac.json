{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BrowserContext = exports.Browser = void 0;\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst Target_js_1 = require(\"./Target.js\");\n\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\n\nconst Connection_js_1 = require(\"./Connection.js\");\n/**\n * A Browser is created when Puppeteer connects to a Chromium instance, either through\n * {@link Puppeteer.launch} or {@link Puppeteer.connect}.\n *\n * @remarks\n *\n * The Browser class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link BrowserEmittedEvents} enum.\n *\n * @example\n *\n * An example of using a {@link Browser} to create a {@link Page}:\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await browser.close();\n * })();\n * ```\n *\n * @example\n *\n * An example of disconnecting from and reconnecting to a {@link Browser}:\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   // Store the endpoint to be able to reconnect to Chromium\n *   const browserWSEndpoint = browser.wsEndpoint();\n *   // Disconnect puppeteer from Chromium\n *   browser.disconnect();\n *\n *   // Use the endpoint to reestablish a connection\n *   const browser2 = await puppeteer.connect({browserWSEndpoint});\n *   // Close Chromium\n *   await browser2.close();\n * })();\n * ```\n *\n * @public\n */\n\n\nclass Browser extends EventEmitter_js_1.EventEmitter {\n  /**\n   * @internal\n   */\n  constructor(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {\n    super();\n    this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this._defaultViewport = defaultViewport;\n    this._process = process;\n    this._connection = connection;\n\n    this._closeCallback = closeCallback || function () {};\n\n    this._defaultContext = new BrowserContext(this._connection, this, null);\n    this._contexts = new Map();\n\n    for (const contextId of contextIds) this._contexts.set(contextId, new BrowserContext(this._connection, this, contextId));\n\n    this._targets = new Map();\n\n    this._connection.on(Connection_js_1.ConnectionEmittedEvents.Disconnected, () => this.emit(\"disconnected\"\n    /* Disconnected */\n    ));\n\n    this._connection.on('Target.targetCreated', this._targetCreated.bind(this));\n\n    this._connection.on('Target.targetDestroyed', this._targetDestroyed.bind(this));\n\n    this._connection.on('Target.targetInfoChanged', this._targetInfoChanged.bind(this));\n  }\n  /**\n   * @internal\n   */\n\n\n  static async create(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {\n    const browser = new Browser(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback);\n    await connection.send('Target.setDiscoverTargets', {\n      discover: true\n    });\n    return browser;\n  }\n  /**\n   * The spawned browser process. Returns `null` if the browser instance was created with\n   * {@link Puppeteer.connect}.\n   */\n\n\n  process() {\n    return this._process;\n  }\n  /**\n   * Creates a new incognito browser context. This won't share cookies/cache with other\n   * browser contexts.\n   *\n   * @example\n   * ```js\n   * (async () => {\n   *  const browser = await puppeteer.launch();\n   *   // Create a new incognito browser context.\n   *   const context = await browser.createIncognitoBrowserContext();\n   *   // Create a new page in a pristine context.\n   *   const page = await context.newPage();\n   *   // Do stuff\n   *   await page.goto('https://example.com');\n   * })();\n   * ```\n   */\n\n\n  async createIncognitoBrowserContext() {\n    const {\n      browserContextId\n    } = await this._connection.send('Target.createBrowserContext');\n    const context = new BrowserContext(this._connection, this, browserContextId);\n\n    this._contexts.set(browserContextId, context);\n\n    return context;\n  }\n  /**\n   * Returns an array of all open browser contexts. In a newly created browser, this will\n   * return a single instance of {@link BrowserContext}.\n   */\n\n\n  browserContexts() {\n    return [this._defaultContext, ...Array.from(this._contexts.values())];\n  }\n  /**\n   * Returns the default browser context. The default browser context cannot be closed.\n   */\n\n\n  defaultBrowserContext() {\n    return this._defaultContext;\n  }\n  /**\n   * @internal\n   * Used by BrowserContext directly so cannot be marked private.\n   */\n\n\n  async _disposeContext(contextId) {\n    await this._connection.send('Target.disposeBrowserContext', {\n      browserContextId: contextId || undefined\n    });\n\n    this._contexts.delete(contextId);\n  }\n\n  async _targetCreated(event) {\n    const targetInfo = event.targetInfo;\n    const {\n      browserContextId\n    } = targetInfo;\n    const context = browserContextId && this._contexts.has(browserContextId) ? this._contexts.get(browserContextId) : this._defaultContext;\n    const target = new Target_js_1.Target(targetInfo, context, () => this._connection.createSession(targetInfo), this._ignoreHTTPSErrors, this._defaultViewport);\n    assert_js_1.assert(!this._targets.has(event.targetInfo.targetId), 'Target should not exist before targetCreated');\n\n    this._targets.set(event.targetInfo.targetId, target);\n\n    if (await target._initializedPromise) {\n      this.emit(\"targetcreated\"\n      /* TargetCreated */\n      , target);\n      context.emit(\"targetcreated\"\n      /* TargetCreated */\n      , target);\n    }\n  }\n\n  async _targetDestroyed(event) {\n    const target = this._targets.get(event.targetId);\n\n    target._initializedCallback(false);\n\n    this._targets.delete(event.targetId);\n\n    target._closedCallback();\n\n    if (await target._initializedPromise) {\n      this.emit(\"targetdestroyed\"\n      /* TargetDestroyed */\n      , target);\n      target.browserContext().emit(\"targetdestroyed\"\n      /* TargetDestroyed */\n      , target);\n    }\n  }\n\n  _targetInfoChanged(event) {\n    const target = this._targets.get(event.targetInfo.targetId);\n\n    assert_js_1.assert(target, 'target should exist before targetInfoChanged');\n    const previousURL = target.url();\n    const wasInitialized = target._isInitialized;\n\n    target._targetInfoChanged(event.targetInfo);\n\n    if (wasInitialized && previousURL !== target.url()) {\n      this.emit(\"targetchanged\"\n      /* TargetChanged */\n      , target);\n      target.browserContext().emit(\"targetchanged\"\n      /* TargetChanged */\n      , target);\n    }\n  }\n  /**\n   * The browser websocket endpoint which can be used as an argument to\n   * {@link Puppeteer.connect}.\n   *\n   * @returns The Browser websocket url.\n   *\n   * @remarks\n   *\n   * The format is `ws://${host}:${port}/devtools/browser/<id>`.\n   *\n   * You can find the `webSocketDebuggerUrl` from `http://${host}:${port}/json/version`.\n   * Learn more about the\n   * {@link https://chromedevtools.github.io/devtools-protocol | devtools protocol} and\n   * the {@link\n   * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target\n   * | browser endpoint}.\n   */\n\n\n  wsEndpoint() {\n    return this._connection.url();\n  }\n  /**\n   * Creates a {@link Page} in the default browser context.\n   */\n\n\n  async newPage() {\n    return this._defaultContext.newPage();\n  }\n  /**\n   * @internal\n   * Used by BrowserContext directly so cannot be marked private.\n   */\n\n\n  async _createPageInContext(contextId) {\n    const {\n      targetId\n    } = await this._connection.send('Target.createTarget', {\n      url: 'about:blank',\n      browserContextId: contextId || undefined\n    });\n    const target = await this._targets.get(targetId);\n    assert_js_1.assert(await target._initializedPromise, 'Failed to create target for page');\n    const page = await target.page();\n    return page;\n  }\n  /**\n   * All active targets inside the Browser. In case of multiple browser contexts, returns\n   * an array with all the targets in all browser contexts.\n   */\n\n\n  targets() {\n    return Array.from(this._targets.values()).filter(target => target._isInitialized);\n  }\n  /**\n   * The target associated with the browser.\n   */\n\n\n  target() {\n    return this.targets().find(target => target.type() === 'browser');\n  }\n  /**\n   * Searches for a target in all browser contexts.\n   *\n   * @param predicate - A function to be run for every target.\n   * @returns The first target found that matches the `predicate` function.\n   *\n   * @example\n   *\n   * An example of finding a target for a page opened via `window.open`:\n   * ```js\n   * await page.evaluate(() => window.open('https://www.example.com/'));\n   * const newWindowTarget = await browser.waitForTarget(target => target.url() === 'https://www.example.com/');\n   * ```\n   */\n\n\n  async waitForTarget(predicate, options = {}) {\n    const {\n      timeout = 30000\n    } = options;\n    const existingTarget = this.targets().find(predicate);\n    if (existingTarget) return existingTarget;\n    let resolve;\n    const targetPromise = new Promise(x => resolve = x);\n    this.on(\"targetcreated\"\n    /* TargetCreated */\n    , check);\n    this.on(\"targetchanged\"\n    /* TargetChanged */\n    , check);\n\n    try {\n      if (!timeout) return await targetPromise;\n      return await helper_js_1.helper.waitWithTimeout(targetPromise, 'target', timeout);\n    } finally {\n      this.removeListener(\"targetcreated\"\n      /* TargetCreated */\n      , check);\n      this.removeListener(\"targetchanged\"\n      /* TargetChanged */\n      , check);\n    }\n\n    function check(target) {\n      if (predicate(target)) resolve(target);\n    }\n  }\n  /**\n   * An array of all open pages inside the Browser.\n   *\n   * @remarks\n   *\n   * In case of multiple browser contexts, returns an array with all the pages in all\n   * browser contexts. Non-visible pages, such as `\"background_page\"`, will not be listed\n   * here. You can find them using {@link Target.page}.\n   */\n\n\n  async pages() {\n    const contextPages = await Promise.all(this.browserContexts().map(context => context.pages())); // Flatten array.\n\n    return contextPages.reduce((acc, x) => acc.concat(x), []);\n  }\n  /**\n   * A string representing the browser name and version.\n   *\n   * @remarks\n   *\n   * For headless Chromium, this is similar to `HeadlessChrome/61.0.3153.0`. For\n   * non-headless, this is similar to `Chrome/61.0.3153.0`.\n   *\n   * The format of browser.version() might change with future releases of Chromium.\n   */\n\n\n  async version() {\n    const version = await this._getVersion();\n    return version.product;\n  }\n  /**\n   * The browser's original user agent. Pages can override the browser user agent with\n   * {@link Page.setUserAgent}.\n   */\n\n\n  async userAgent() {\n    const version = await this._getVersion();\n    return version.userAgent;\n  }\n  /**\n   * Closes Chromium and all of its pages (if any were opened). The {@link Browser} object\n   * itself is considered to be disposed and cannot be used anymore.\n   */\n\n\n  async close() {\n    await this._closeCallback.call(null);\n    this.disconnect();\n  }\n  /**\n   * Disconnects Puppeteer from the browser, but leaves the Chromium process running.\n   * After calling `disconnect`, the {@link Browser} object is considered disposed and\n   * cannot be used anymore.\n   */\n\n\n  disconnect() {\n    this._connection.dispose();\n  }\n  /**\n   * Indicates that the browser is connected.\n   */\n\n\n  isConnected() {\n    return !this._connection._closed;\n  }\n\n  _getVersion() {\n    return this._connection.send('Browser.getVersion');\n  }\n\n}\n\nexports.Browser = Browser;\n/**\n * BrowserContexts provide a way to operate multiple independent browser\n * sessions. When a browser is launched, it has a single BrowserContext used by\n * default. The method {@link Browser.newPage | Browser.newPage} creates a page\n * in the default browser context.\n *\n * @remarks\n *\n * The Browser class extends from Puppeteer's {@link EventEmitter} class and\n * will emit various events which are documented in the\n * {@link BrowserContextEmittedEvents} enum.\n *\n * If a page opens another page, e.g. with a `window.open` call, the popup will\n * belong to the parent page's browser context.\n *\n * Puppeteer allows creation of \"incognito\" browser contexts with\n * {@link Browser.createIncognitoBrowserContext | Browser.createIncognitoBrowserContext}\n * method. \"Incognito\" browser contexts don't write any browsing data to disk.\n *\n * @example\n * ```js\n * // Create a new incognito browser context\n * const context = await browser.createIncognitoBrowserContext();\n * // Create a new page inside context.\n * const page = await context.newPage();\n * // ... do stuff with page ...\n * await page.goto('https://example.com');\n * // Dispose context once it's no longer needed.\n * await context.close();\n * ```\n */\n\nclass BrowserContext extends EventEmitter_js_1.EventEmitter {\n  /**\n   * @internal\n   */\n  constructor(connection, browser, contextId) {\n    super();\n    this._connection = connection;\n    this._browser = browser;\n    this._id = contextId;\n  }\n  /**\n   * An array of all active targets inside the browser context.\n   */\n\n\n  targets() {\n    return this._browser.targets().filter(target => target.browserContext() === this);\n  }\n  /**\n   * This searches for a target in this specific browser context.\n   *\n   * @example\n   * An example of finding a target for a page opened via `window.open`:\n   * ```js\n   * await page.evaluate(() => window.open('https://www.example.com/'));\n   * const newWindowTarget = await browserContext.waitForTarget(target => target.url() === 'https://www.example.com/');\n   * ```\n   *\n   * @param predicate - A function to be run for every target\n   * @param options - An object of options. Accepts a timout,\n   * which is the maximum wait time in milliseconds.\n   * Pass `0` to disable the timeout. Defaults to 30 seconds.\n   * @returns Promise which resolves to the first target found\n   * that matches the `predicate` function.\n   */\n\n\n  waitForTarget(predicate, options = {}) {\n    return this._browser.waitForTarget(target => target.browserContext() === this && predicate(target), options);\n  }\n  /**\n   * An array of all pages inside the browser context.\n   *\n   * @returns Promise which resolves to an array of all open pages.\n   * Non visible pages, such as `\"background_page\"`, will not be listed here.\n   * You can find them using {@link Target.page | the target page}.\n   */\n\n\n  async pages() {\n    const pages = await Promise.all(this.targets().filter(target => target.type() === 'page').map(target => target.page()));\n    return pages.filter(page => !!page);\n  }\n  /**\n   * Returns whether BrowserContext is incognito.\n   * The default browser context is the only non-incognito browser context.\n   *\n   * @remarks\n   * The default browser context cannot be closed.\n   */\n\n\n  isIncognito() {\n    return !!this._id;\n  }\n  /**\n   * @example\n   * ```js\n   * const context = browser.defaultBrowserContext();\n   * await context.overridePermissions('https://html5demos.com', ['geolocation']);\n   * ```\n   *\n   * @param origin - The origin to grant permissions to, e.g. \"https://example.com\".\n   * @param permissions - An array of permissions to grant.\n   * All permissions that are not listed here will be automatically denied.\n   */\n\n\n  async overridePermissions(origin, permissions) {\n    const webPermissionToProtocol = new Map([['geolocation', 'geolocation'], ['midi', 'midi'], ['notifications', 'notifications'], // TODO: push isn't a valid type?\n    // ['push', 'push'],\n    ['camera', 'videoCapture'], ['microphone', 'audioCapture'], ['background-sync', 'backgroundSync'], ['ambient-light-sensor', 'sensors'], ['accelerometer', 'sensors'], ['gyroscope', 'sensors'], ['magnetometer', 'sensors'], ['accessibility-events', 'accessibilityEvents'], ['clipboard-read', 'clipboardReadWrite'], ['clipboard-write', 'clipboardReadWrite'], ['payment-handler', 'paymentHandler'], // chrome-specific permissions we have.\n    ['midi-sysex', 'midiSysex']]);\n    permissions = permissions.map(permission => {\n      const protocolPermission = webPermissionToProtocol.get(permission);\n      if (!protocolPermission) throw new Error('Unknown permission: ' + permission);\n      return protocolPermission;\n    });\n    await this._connection.send('Browser.grantPermissions', {\n      origin,\n      browserContextId: this._id || undefined,\n      permissions\n    });\n  }\n  /**\n   * Clears all permission overrides for the browser context.\n   *\n   * @example\n   * ```js\n   * const context = browser.defaultBrowserContext();\n   * context.overridePermissions('https://example.com', ['clipboard-read']);\n   * // do stuff ..\n   * context.clearPermissionOverrides();\n   * ```\n   */\n\n\n  async clearPermissionOverrides() {\n    await this._connection.send('Browser.resetPermissions', {\n      browserContextId: this._id || undefined\n    });\n  }\n  /**\n   * Creates a new page in the browser context.\n   */\n\n\n  newPage() {\n    return this._browser._createPageInContext(this._id);\n  }\n  /**\n   * The browser this browser context belongs to.\n   */\n\n\n  browser() {\n    return this._browser;\n  }\n  /**\n   * Closes the browser context. All the targets that belong to the browser context\n   * will be closed.\n   *\n   * @remarks\n   * Only incognito browser contexts can be closed.\n   */\n\n\n  async close() {\n    assert_js_1.assert(this._id, 'Non-incognito profiles cannot be closed!');\n    await this._browser._disposeContext(this._id);\n  }\n\n}\n\nexports.BrowserContext = BrowserContext;","map":{"version":3,"sources":["C:/Users/Sajjad Brohi/JavaScript Projects/RESTful API/packages/client/node_modules/puppeteer/lib/cjs/puppeteer/common/Browser.js"],"names":["Object","defineProperty","exports","value","BrowserContext","Browser","assert_js_1","require","helper_js_1","Target_js_1","EventEmitter_js_1","Connection_js_1","EventEmitter","constructor","connection","contextIds","ignoreHTTPSErrors","defaultViewport","process","closeCallback","_ignoreHTTPSErrors","_defaultViewport","_process","_connection","_closeCallback","_defaultContext","_contexts","Map","contextId","set","_targets","on","ConnectionEmittedEvents","Disconnected","emit","_targetCreated","bind","_targetDestroyed","_targetInfoChanged","create","browser","send","discover","createIncognitoBrowserContext","browserContextId","context","browserContexts","Array","from","values","defaultBrowserContext","_disposeContext","undefined","delete","event","targetInfo","has","get","target","Target","createSession","assert","targetId","_initializedPromise","_initializedCallback","_closedCallback","browserContext","previousURL","url","wasInitialized","_isInitialized","wsEndpoint","newPage","_createPageInContext","page","targets","filter","find","type","waitForTarget","predicate","options","timeout","existingTarget","resolve","targetPromise","Promise","x","check","helper","waitWithTimeout","removeListener","pages","contextPages","all","map","reduce","acc","concat","version","_getVersion","product","userAgent","close","call","disconnect","dispose","isConnected","_closed","_browser","_id","isIncognito","overridePermissions","origin","permissions","webPermissionToProtocol","permission","protocolPermission","Error","clearPermissionOverrides"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BrowserContext = exports.Browser = void 0;\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst Target_js_1 = require(\"./Target.js\");\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\nconst Connection_js_1 = require(\"./Connection.js\");\n/**\n * A Browser is created when Puppeteer connects to a Chromium instance, either through\n * {@link Puppeteer.launch} or {@link Puppeteer.connect}.\n *\n * @remarks\n *\n * The Browser class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link BrowserEmittedEvents} enum.\n *\n * @example\n *\n * An example of using a {@link Browser} to create a {@link Page}:\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await browser.close();\n * })();\n * ```\n *\n * @example\n *\n * An example of disconnecting from and reconnecting to a {@link Browser}:\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   // Store the endpoint to be able to reconnect to Chromium\n *   const browserWSEndpoint = browser.wsEndpoint();\n *   // Disconnect puppeteer from Chromium\n *   browser.disconnect();\n *\n *   // Use the endpoint to reestablish a connection\n *   const browser2 = await puppeteer.connect({browserWSEndpoint});\n *   // Close Chromium\n *   await browser2.close();\n * })();\n * ```\n *\n * @public\n */\nclass Browser extends EventEmitter_js_1.EventEmitter {\n    /**\n     * @internal\n     */\n    constructor(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {\n        super();\n        this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n        this._defaultViewport = defaultViewport;\n        this._process = process;\n        this._connection = connection;\n        this._closeCallback = closeCallback || function () { };\n        this._defaultContext = new BrowserContext(this._connection, this, null);\n        this._contexts = new Map();\n        for (const contextId of contextIds)\n            this._contexts.set(contextId, new BrowserContext(this._connection, this, contextId));\n        this._targets = new Map();\n        this._connection.on(Connection_js_1.ConnectionEmittedEvents.Disconnected, () => this.emit(\"disconnected\" /* Disconnected */));\n        this._connection.on('Target.targetCreated', this._targetCreated.bind(this));\n        this._connection.on('Target.targetDestroyed', this._targetDestroyed.bind(this));\n        this._connection.on('Target.targetInfoChanged', this._targetInfoChanged.bind(this));\n    }\n    /**\n     * @internal\n     */\n    static async create(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {\n        const browser = new Browser(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback);\n        await connection.send('Target.setDiscoverTargets', { discover: true });\n        return browser;\n    }\n    /**\n     * The spawned browser process. Returns `null` if the browser instance was created with\n     * {@link Puppeteer.connect}.\n     */\n    process() {\n        return this._process;\n    }\n    /**\n     * Creates a new incognito browser context. This won't share cookies/cache with other\n     * browser contexts.\n     *\n     * @example\n     * ```js\n     * (async () => {\n     *  const browser = await puppeteer.launch();\n     *   // Create a new incognito browser context.\n     *   const context = await browser.createIncognitoBrowserContext();\n     *   // Create a new page in a pristine context.\n     *   const page = await context.newPage();\n     *   // Do stuff\n     *   await page.goto('https://example.com');\n     * })();\n     * ```\n     */\n    async createIncognitoBrowserContext() {\n        const { browserContextId } = await this._connection.send('Target.createBrowserContext');\n        const context = new BrowserContext(this._connection, this, browserContextId);\n        this._contexts.set(browserContextId, context);\n        return context;\n    }\n    /**\n     * Returns an array of all open browser contexts. In a newly created browser, this will\n     * return a single instance of {@link BrowserContext}.\n     */\n    browserContexts() {\n        return [this._defaultContext, ...Array.from(this._contexts.values())];\n    }\n    /**\n     * Returns the default browser context. The default browser context cannot be closed.\n     */\n    defaultBrowserContext() {\n        return this._defaultContext;\n    }\n    /**\n     * @internal\n     * Used by BrowserContext directly so cannot be marked private.\n     */\n    async _disposeContext(contextId) {\n        await this._connection.send('Target.disposeBrowserContext', {\n            browserContextId: contextId || undefined,\n        });\n        this._contexts.delete(contextId);\n    }\n    async _targetCreated(event) {\n        const targetInfo = event.targetInfo;\n        const { browserContextId } = targetInfo;\n        const context = browserContextId && this._contexts.has(browserContextId)\n            ? this._contexts.get(browserContextId)\n            : this._defaultContext;\n        const target = new Target_js_1.Target(targetInfo, context, () => this._connection.createSession(targetInfo), this._ignoreHTTPSErrors, this._defaultViewport);\n        assert_js_1.assert(!this._targets.has(event.targetInfo.targetId), 'Target should not exist before targetCreated');\n        this._targets.set(event.targetInfo.targetId, target);\n        if (await target._initializedPromise) {\n            this.emit(\"targetcreated\" /* TargetCreated */, target);\n            context.emit(\"targetcreated\" /* TargetCreated */, target);\n        }\n    }\n    async _targetDestroyed(event) {\n        const target = this._targets.get(event.targetId);\n        target._initializedCallback(false);\n        this._targets.delete(event.targetId);\n        target._closedCallback();\n        if (await target._initializedPromise) {\n            this.emit(\"targetdestroyed\" /* TargetDestroyed */, target);\n            target\n                .browserContext()\n                .emit(\"targetdestroyed\" /* TargetDestroyed */, target);\n        }\n    }\n    _targetInfoChanged(event) {\n        const target = this._targets.get(event.targetInfo.targetId);\n        assert_js_1.assert(target, 'target should exist before targetInfoChanged');\n        const previousURL = target.url();\n        const wasInitialized = target._isInitialized;\n        target._targetInfoChanged(event.targetInfo);\n        if (wasInitialized && previousURL !== target.url()) {\n            this.emit(\"targetchanged\" /* TargetChanged */, target);\n            target\n                .browserContext()\n                .emit(\"targetchanged\" /* TargetChanged */, target);\n        }\n    }\n    /**\n     * The browser websocket endpoint which can be used as an argument to\n     * {@link Puppeteer.connect}.\n     *\n     * @returns The Browser websocket url.\n     *\n     * @remarks\n     *\n     * The format is `ws://${host}:${port}/devtools/browser/<id>`.\n     *\n     * You can find the `webSocketDebuggerUrl` from `http://${host}:${port}/json/version`.\n     * Learn more about the\n     * {@link https://chromedevtools.github.io/devtools-protocol | devtools protocol} and\n     * the {@link\n     * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target\n     * | browser endpoint}.\n     */\n    wsEndpoint() {\n        return this._connection.url();\n    }\n    /**\n     * Creates a {@link Page} in the default browser context.\n     */\n    async newPage() {\n        return this._defaultContext.newPage();\n    }\n    /**\n     * @internal\n     * Used by BrowserContext directly so cannot be marked private.\n     */\n    async _createPageInContext(contextId) {\n        const { targetId } = await this._connection.send('Target.createTarget', {\n            url: 'about:blank',\n            browserContextId: contextId || undefined,\n        });\n        const target = await this._targets.get(targetId);\n        assert_js_1.assert(await target._initializedPromise, 'Failed to create target for page');\n        const page = await target.page();\n        return page;\n    }\n    /**\n     * All active targets inside the Browser. In case of multiple browser contexts, returns\n     * an array with all the targets in all browser contexts.\n     */\n    targets() {\n        return Array.from(this._targets.values()).filter((target) => target._isInitialized);\n    }\n    /**\n     * The target associated with the browser.\n     */\n    target() {\n        return this.targets().find((target) => target.type() === 'browser');\n    }\n    /**\n     * Searches for a target in all browser contexts.\n     *\n     * @param predicate - A function to be run for every target.\n     * @returns The first target found that matches the `predicate` function.\n     *\n     * @example\n     *\n     * An example of finding a target for a page opened via `window.open`:\n     * ```js\n     * await page.evaluate(() => window.open('https://www.example.com/'));\n     * const newWindowTarget = await browser.waitForTarget(target => target.url() === 'https://www.example.com/');\n     * ```\n     */\n    async waitForTarget(predicate, options = {}) {\n        const { timeout = 30000 } = options;\n        const existingTarget = this.targets().find(predicate);\n        if (existingTarget)\n            return existingTarget;\n        let resolve;\n        const targetPromise = new Promise((x) => (resolve = x));\n        this.on(\"targetcreated\" /* TargetCreated */, check);\n        this.on(\"targetchanged\" /* TargetChanged */, check);\n        try {\n            if (!timeout)\n                return await targetPromise;\n            return await helper_js_1.helper.waitWithTimeout(targetPromise, 'target', timeout);\n        }\n        finally {\n            this.removeListener(\"targetcreated\" /* TargetCreated */, check);\n            this.removeListener(\"targetchanged\" /* TargetChanged */, check);\n        }\n        function check(target) {\n            if (predicate(target))\n                resolve(target);\n        }\n    }\n    /**\n     * An array of all open pages inside the Browser.\n     *\n     * @remarks\n     *\n     * In case of multiple browser contexts, returns an array with all the pages in all\n     * browser contexts. Non-visible pages, such as `\"background_page\"`, will not be listed\n     * here. You can find them using {@link Target.page}.\n     */\n    async pages() {\n        const contextPages = await Promise.all(this.browserContexts().map((context) => context.pages()));\n        // Flatten array.\n        return contextPages.reduce((acc, x) => acc.concat(x), []);\n    }\n    /**\n     * A string representing the browser name and version.\n     *\n     * @remarks\n     *\n     * For headless Chromium, this is similar to `HeadlessChrome/61.0.3153.0`. For\n     * non-headless, this is similar to `Chrome/61.0.3153.0`.\n     *\n     * The format of browser.version() might change with future releases of Chromium.\n     */\n    async version() {\n        const version = await this._getVersion();\n        return version.product;\n    }\n    /**\n     * The browser's original user agent. Pages can override the browser user agent with\n     * {@link Page.setUserAgent}.\n     */\n    async userAgent() {\n        const version = await this._getVersion();\n        return version.userAgent;\n    }\n    /**\n     * Closes Chromium and all of its pages (if any were opened). The {@link Browser} object\n     * itself is considered to be disposed and cannot be used anymore.\n     */\n    async close() {\n        await this._closeCallback.call(null);\n        this.disconnect();\n    }\n    /**\n     * Disconnects Puppeteer from the browser, but leaves the Chromium process running.\n     * After calling `disconnect`, the {@link Browser} object is considered disposed and\n     * cannot be used anymore.\n     */\n    disconnect() {\n        this._connection.dispose();\n    }\n    /**\n     * Indicates that the browser is connected.\n     */\n    isConnected() {\n        return !this._connection._closed;\n    }\n    _getVersion() {\n        return this._connection.send('Browser.getVersion');\n    }\n}\nexports.Browser = Browser;\n/**\n * BrowserContexts provide a way to operate multiple independent browser\n * sessions. When a browser is launched, it has a single BrowserContext used by\n * default. The method {@link Browser.newPage | Browser.newPage} creates a page\n * in the default browser context.\n *\n * @remarks\n *\n * The Browser class extends from Puppeteer's {@link EventEmitter} class and\n * will emit various events which are documented in the\n * {@link BrowserContextEmittedEvents} enum.\n *\n * If a page opens another page, e.g. with a `window.open` call, the popup will\n * belong to the parent page's browser context.\n *\n * Puppeteer allows creation of \"incognito\" browser contexts with\n * {@link Browser.createIncognitoBrowserContext | Browser.createIncognitoBrowserContext}\n * method. \"Incognito\" browser contexts don't write any browsing data to disk.\n *\n * @example\n * ```js\n * // Create a new incognito browser context\n * const context = await browser.createIncognitoBrowserContext();\n * // Create a new page inside context.\n * const page = await context.newPage();\n * // ... do stuff with page ...\n * await page.goto('https://example.com');\n * // Dispose context once it's no longer needed.\n * await context.close();\n * ```\n */\nclass BrowserContext extends EventEmitter_js_1.EventEmitter {\n    /**\n     * @internal\n     */\n    constructor(connection, browser, contextId) {\n        super();\n        this._connection = connection;\n        this._browser = browser;\n        this._id = contextId;\n    }\n    /**\n     * An array of all active targets inside the browser context.\n     */\n    targets() {\n        return this._browser\n            .targets()\n            .filter((target) => target.browserContext() === this);\n    }\n    /**\n     * This searches for a target in this specific browser context.\n     *\n     * @example\n     * An example of finding a target for a page opened via `window.open`:\n     * ```js\n     * await page.evaluate(() => window.open('https://www.example.com/'));\n     * const newWindowTarget = await browserContext.waitForTarget(target => target.url() === 'https://www.example.com/');\n     * ```\n     *\n     * @param predicate - A function to be run for every target\n     * @param options - An object of options. Accepts a timout,\n     * which is the maximum wait time in milliseconds.\n     * Pass `0` to disable the timeout. Defaults to 30 seconds.\n     * @returns Promise which resolves to the first target found\n     * that matches the `predicate` function.\n     */\n    waitForTarget(predicate, options = {}) {\n        return this._browser.waitForTarget((target) => target.browserContext() === this && predicate(target), options);\n    }\n    /**\n     * An array of all pages inside the browser context.\n     *\n     * @returns Promise which resolves to an array of all open pages.\n     * Non visible pages, such as `\"background_page\"`, will not be listed here.\n     * You can find them using {@link Target.page | the target page}.\n     */\n    async pages() {\n        const pages = await Promise.all(this.targets()\n            .filter((target) => target.type() === 'page')\n            .map((target) => target.page()));\n        return pages.filter((page) => !!page);\n    }\n    /**\n     * Returns whether BrowserContext is incognito.\n     * The default browser context is the only non-incognito browser context.\n     *\n     * @remarks\n     * The default browser context cannot be closed.\n     */\n    isIncognito() {\n        return !!this._id;\n    }\n    /**\n     * @example\n     * ```js\n     * const context = browser.defaultBrowserContext();\n     * await context.overridePermissions('https://html5demos.com', ['geolocation']);\n     * ```\n     *\n     * @param origin - The origin to grant permissions to, e.g. \"https://example.com\".\n     * @param permissions - An array of permissions to grant.\n     * All permissions that are not listed here will be automatically denied.\n     */\n    async overridePermissions(origin, permissions) {\n        const webPermissionToProtocol = new Map([\n            ['geolocation', 'geolocation'],\n            ['midi', 'midi'],\n            ['notifications', 'notifications'],\n            // TODO: push isn't a valid type?\n            // ['push', 'push'],\n            ['camera', 'videoCapture'],\n            ['microphone', 'audioCapture'],\n            ['background-sync', 'backgroundSync'],\n            ['ambient-light-sensor', 'sensors'],\n            ['accelerometer', 'sensors'],\n            ['gyroscope', 'sensors'],\n            ['magnetometer', 'sensors'],\n            ['accessibility-events', 'accessibilityEvents'],\n            ['clipboard-read', 'clipboardReadWrite'],\n            ['clipboard-write', 'clipboardReadWrite'],\n            ['payment-handler', 'paymentHandler'],\n            // chrome-specific permissions we have.\n            ['midi-sysex', 'midiSysex'],\n        ]);\n        permissions = permissions.map((permission) => {\n            const protocolPermission = webPermissionToProtocol.get(permission);\n            if (!protocolPermission)\n                throw new Error('Unknown permission: ' + permission);\n            return protocolPermission;\n        });\n        await this._connection.send('Browser.grantPermissions', {\n            origin,\n            browserContextId: this._id || undefined,\n            permissions,\n        });\n    }\n    /**\n     * Clears all permission overrides for the browser context.\n     *\n     * @example\n     * ```js\n     * const context = browser.defaultBrowserContext();\n     * context.overridePermissions('https://example.com', ['clipboard-read']);\n     * // do stuff ..\n     * context.clearPermissionOverrides();\n     * ```\n     */\n    async clearPermissionOverrides() {\n        await this._connection.send('Browser.resetPermissions', {\n            browserContextId: this._id || undefined,\n        });\n    }\n    /**\n     * Creates a new page in the browser context.\n     */\n    newPage() {\n        return this._browser._createPageInContext(this._id);\n    }\n    /**\n     * The browser this browser context belongs to.\n     */\n    browser() {\n        return this._browser;\n    }\n    /**\n     * Closes the browser context. All the targets that belong to the browser context\n     * will be closed.\n     *\n     * @remarks\n     * Only incognito browser contexts can be closed.\n     */\n    async close() {\n        assert_js_1.assert(this._id, 'Non-incognito profiles cannot be closed!');\n        await this._browser._disposeContext(this._id);\n    }\n}\nexports.BrowserContext = BrowserContext;\n"]},"metadata":{},"sourceType":"script"}