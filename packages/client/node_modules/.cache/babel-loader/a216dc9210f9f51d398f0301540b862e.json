{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\n\nfunction mitt(all) {\n  all = all || new Map();\n  return {\n    /**\n     * A Map of event names to registered handler functions.\n     */\n    all,\n\n    /**\n     * Register an event handler for the given type.\n     * @param {string|symbol} type Type of event to listen for, or `\"*\"` for all events\n     * @param {Function} handler Function to call in response to given event\n     * @memberOf mitt\n     */\n    on(type, handler) {\n      const handlers = all.get(type);\n      const added = handlers && handlers.push(handler);\n\n      if (!added) {\n        all.set(type, [handler]);\n      }\n    },\n\n    /**\n     * Remove an event handler for the given type.\n     * @param {string|symbol} type Type of event to unregister `handler` from, or `\"*\"`\n     * @param {Function} handler Handler function to remove\n     * @memberOf mitt\n     */\n    off(type, handler) {\n      const handlers = all.get(type);\n\n      if (handlers) {\n        handlers.splice(handlers.indexOf(handler) >>> 0, 1);\n      }\n    },\n\n    /**\n     * Invoke all handlers for the given type.\n     * If present, `\"*\"` handlers are invoked after type-matched handlers.\n     *\n     * Note: Manually firing \"*\" handlers is not supported.\n     *\n     * @param {string|symbol} type The event type to invoke\n     * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n     * @memberOf mitt\n     */\n    emit(type, evt) {\n      (all.get(type) || []).slice().map(handler => {\n        handler(evt);\n      });\n      (all.get('*') || []).slice().map(handler => {\n        handler(type, evt);\n      });\n    }\n\n  };\n}\n\nexports.default = mitt;","map":{"version":3,"sources":["C:/Users/Sajjad Brohi/JavaScript Projects/RESTful API/packages/client/node_modules/puppeteer/lib/cjs/vendor/mitt/src/index.js"],"names":["Object","defineProperty","exports","value","mitt","all","Map","on","type","handler","handlers","get","added","push","set","off","splice","indexOf","emit","evt","slice","map","default"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;;;;;;AAKA,SAASC,IAAT,CAAcC,GAAd,EAAmB;AACfA,EAAAA,GAAG,GAAGA,GAAG,IAAI,IAAIC,GAAJ,EAAb;AACA,SAAO;AACH;;;AAGAD,IAAAA,GAJG;;AAKH;;;;;;AAMAE,IAAAA,EAAE,CAACC,IAAD,EAAOC,OAAP,EAAgB;AACd,YAAMC,QAAQ,GAAGL,GAAG,CAACM,GAAJ,CAAQH,IAAR,CAAjB;AACA,YAAMI,KAAK,GAAGF,QAAQ,IAAIA,QAAQ,CAACG,IAAT,CAAcJ,OAAd,CAA1B;;AACA,UAAI,CAACG,KAAL,EAAY;AACRP,QAAAA,GAAG,CAACS,GAAJ,CAAQN,IAAR,EAAc,CAACC,OAAD,CAAd;AACH;AACJ,KAjBE;;AAkBH;;;;;;AAMAM,IAAAA,GAAG,CAACP,IAAD,EAAOC,OAAP,EAAgB;AACf,YAAMC,QAAQ,GAAGL,GAAG,CAACM,GAAJ,CAAQH,IAAR,CAAjB;;AACA,UAAIE,QAAJ,EAAc;AACVA,QAAAA,QAAQ,CAACM,MAAT,CAAgBN,QAAQ,CAACO,OAAT,CAAiBR,OAAjB,MAA8B,CAA9C,EAAiD,CAAjD;AACH;AACJ,KA7BE;;AA8BH;;;;;;;;;;AAUAS,IAAAA,IAAI,CAACV,IAAD,EAAOW,GAAP,EAAY;AACZ,OAACd,GAAG,CAACM,GAAJ,CAAQH,IAAR,KAAiB,EAAlB,EAAsBY,KAAtB,GAA8BC,GAA9B,CAAmCZ,OAAD,IAAa;AAAEA,QAAAA,OAAO,CAACU,GAAD,CAAP;AAAe,OAAhE;AACA,OAACd,GAAG,CAACM,GAAJ,CAAQ,GAAR,KAAgB,EAAjB,EAAqBS,KAArB,GAA6BC,GAA7B,CAAkCZ,OAAD,IAAa;AAAEA,QAAAA,OAAO,CAACD,IAAD,EAAOW,GAAP,CAAP;AAAqB,OAArE;AACH;;AA3CE,GAAP;AA6CH;;AACDjB,OAAO,CAACoB,OAAR,GAAkBlB,IAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nfunction mitt(all) {\n    all = all || new Map();\n    return {\n        /**\n         * A Map of event names to registered handler functions.\n         */\n        all,\n        /**\n         * Register an event handler for the given type.\n         * @param {string|symbol} type Type of event to listen for, or `\"*\"` for all events\n         * @param {Function} handler Function to call in response to given event\n         * @memberOf mitt\n         */\n        on(type, handler) {\n            const handlers = all.get(type);\n            const added = handlers && handlers.push(handler);\n            if (!added) {\n                all.set(type, [handler]);\n            }\n        },\n        /**\n         * Remove an event handler for the given type.\n         * @param {string|symbol} type Type of event to unregister `handler` from, or `\"*\"`\n         * @param {Function} handler Handler function to remove\n         * @memberOf mitt\n         */\n        off(type, handler) {\n            const handlers = all.get(type);\n            if (handlers) {\n                handlers.splice(handlers.indexOf(handler) >>> 0, 1);\n            }\n        },\n        /**\n         * Invoke all handlers for the given type.\n         * If present, `\"*\"` handlers are invoked after type-matched handlers.\n         *\n         * Note: Manually firing \"*\" handlers is not supported.\n         *\n         * @param {string|symbol} type The event type to invoke\n         * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n         * @memberOf mitt\n         */\n        emit(type, evt) {\n            (all.get(type) || []).slice().map((handler) => { handler(evt); });\n            (all.get('*') || []).slice().map((handler) => { handler(type, evt); });\n        }\n    };\n}\nexports.default = mitt;\n"]},"metadata":{},"sourceType":"script"}