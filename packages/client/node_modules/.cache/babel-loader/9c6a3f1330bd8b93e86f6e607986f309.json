{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventEmitter = void 0;\n\nconst index_js_1 = __importDefault(require(\"../../vendor/mitt/src/index.js\"));\n/**\n * The EventEmitter class that many Puppeteer classes extend.\n *\n * @remarks\n *\n * This allows you to listen to events that Puppeteer classes fire and act\n * accordingly. Therefore you'll mostly use {@link EventEmitter.on | on} and\n * {@link EventEmitter.off | off} to bind\n * and unbind to event listeners.\n *\n * @public\n */\n\n\nclass EventEmitter {\n  /**\n   * @internal\n   */\n  constructor() {\n    this.eventsMap = new Map();\n    this.emitter = index_js_1.default(this.eventsMap);\n  }\n  /**\n   * Bind an event listener to fire when an event occurs.\n   * @param event - the event type you'd like to listen to. Can be a string or symbol.\n   * @param handler  - the function to be called when the event occurs.\n   * @returns `this` to enable you to chain calls.\n   */\n\n\n  on(event, handler) {\n    this.emitter.on(event, handler);\n    return this;\n  }\n  /**\n   * Remove an event listener from firing.\n   * @param event - the event type you'd like to stop listening to.\n   * @param handler  - the function that should be removed.\n   * @returns `this` to enable you to chain calls.\n   */\n\n\n  off(event, handler) {\n    this.emitter.off(event, handler);\n    return this;\n  }\n  /**\n   * Remove an event listener.\n   * @deprecated please use `off` instead.\n   */\n\n\n  removeListener(event, handler) {\n    this.off(event, handler);\n    return this;\n  }\n  /**\n   * Add an event listener.\n   * @deprecated please use `on` instead.\n   */\n\n\n  addListener(event, handler) {\n    this.on(event, handler);\n    return this;\n  }\n  /**\n   * Emit an event and call any associated listeners.\n   *\n   * @param event - the event you'd like to emit\n   * @param eventData - any data you'd like to emit with the event\n   * @returns `true` if there are any listeners, `false` if there are not.\n   */\n\n\n  emit(event, eventData) {\n    this.emitter.emit(event, eventData);\n    return this.eventListenersCount(event) > 0;\n  }\n  /**\n   * Like `on` but the listener will only be fired once and then it will be removed.\n   * @param event - the event you'd like to listen to\n   * @param handler - the handler function to run when the event occurs\n   * @returns `this` to enable you to chain calls.\n   */\n\n\n  once(event, handler) {\n    const onceHandler = eventData => {\n      handler(eventData);\n      this.off(event, onceHandler);\n    };\n\n    return this.on(event, onceHandler);\n  }\n  /**\n   * Gets the number of listeners for a given event.\n   *\n   * @param event - the event to get the listener count for\n   * @returns the number of listeners bound to the given event\n   */\n\n\n  listenerCount(event) {\n    return this.eventListenersCount(event);\n  }\n  /**\n   * Removes all listeners. If given an event argument, it will remove only\n   * listeners for that event.\n   * @param event - the event to remove listeners for.\n   * @returns `this` to enable you to chain calls.\n   */\n\n\n  removeAllListeners(event) {\n    if (event) {\n      this.eventsMap.delete(event);\n    } else {\n      this.eventsMap.clear();\n    }\n\n    return this;\n  }\n\n  eventListenersCount(event) {\n    return this.eventsMap.has(event) ? this.eventsMap.get(event).length : 0;\n  }\n\n}\n\nexports.EventEmitter = EventEmitter;","map":{"version":3,"sources":["C:/Users/Sajjad Brohi/JavaScript Projects/RESTful API/packages/client/node_modules/puppeteer/lib/cjs/puppeteer/common/EventEmitter.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","EventEmitter","index_js_1","require","constructor","eventsMap","Map","emitter","default","on","event","handler","off","removeListener","addListener","emit","eventData","eventListenersCount","once","onceHandler","listenerCount","removeAllListeners","delete","clear","has","get","length"],"mappings":"AAAA;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,YAAR,GAAuB,KAAK,CAA5B;;AACA,MAAMC,UAAU,GAAGR,eAAe,CAACS,OAAO,CAAC,gCAAD,CAAR,CAAlC;AACA;;;;;;;;;;;;;;AAYA,MAAMF,YAAN,CAAmB;AACf;;;AAGAG,EAAAA,WAAW,GAAG;AACV,SAAKC,SAAL,GAAiB,IAAIC,GAAJ,EAAjB;AACA,SAAKC,OAAL,GAAeL,UAAU,CAACM,OAAX,CAAmB,KAAKH,SAAxB,CAAf;AACH;AACD;;;;;;;;AAMAI,EAAAA,EAAE,CAACC,KAAD,EAAQC,OAAR,EAAiB;AACf,SAAKJ,OAAL,CAAaE,EAAb,CAAgBC,KAAhB,EAAuBC,OAAvB;AACA,WAAO,IAAP;AACH;AACD;;;;;;;;AAMAC,EAAAA,GAAG,CAACF,KAAD,EAAQC,OAAR,EAAiB;AAChB,SAAKJ,OAAL,CAAaK,GAAb,CAAiBF,KAAjB,EAAwBC,OAAxB;AACA,WAAO,IAAP;AACH;AACD;;;;;;AAIAE,EAAAA,cAAc,CAACH,KAAD,EAAQC,OAAR,EAAiB;AAC3B,SAAKC,GAAL,CAASF,KAAT,EAAgBC,OAAhB;AACA,WAAO,IAAP;AACH;AACD;;;;;;AAIAG,EAAAA,WAAW,CAACJ,KAAD,EAAQC,OAAR,EAAiB;AACxB,SAAKF,EAAL,CAAQC,KAAR,EAAeC,OAAf;AACA,WAAO,IAAP;AACH;AACD;;;;;;;;;AAOAI,EAAAA,IAAI,CAACL,KAAD,EAAQM,SAAR,EAAmB;AACnB,SAAKT,OAAL,CAAaQ,IAAb,CAAkBL,KAAlB,EAAyBM,SAAzB;AACA,WAAO,KAAKC,mBAAL,CAAyBP,KAAzB,IAAkC,CAAzC;AACH;AACD;;;;;;;;AAMAQ,EAAAA,IAAI,CAACR,KAAD,EAAQC,OAAR,EAAiB;AACjB,UAAMQ,WAAW,GAAIH,SAAD,IAAe;AAC/BL,MAAAA,OAAO,CAACK,SAAD,CAAP;AACA,WAAKJ,GAAL,CAASF,KAAT,EAAgBS,WAAhB;AACH,KAHD;;AAIA,WAAO,KAAKV,EAAL,CAAQC,KAAR,EAAeS,WAAf,CAAP;AACH;AACD;;;;;;;;AAMAC,EAAAA,aAAa,CAACV,KAAD,EAAQ;AACjB,WAAO,KAAKO,mBAAL,CAAyBP,KAAzB,CAAP;AACH;AACD;;;;;;;;AAMAW,EAAAA,kBAAkB,CAACX,KAAD,EAAQ;AACtB,QAAIA,KAAJ,EAAW;AACP,WAAKL,SAAL,CAAeiB,MAAf,CAAsBZ,KAAtB;AACH,KAFD,MAGK;AACD,WAAKL,SAAL,CAAekB,KAAf;AACH;;AACD,WAAO,IAAP;AACH;;AACDN,EAAAA,mBAAmB,CAACP,KAAD,EAAQ;AACvB,WAAO,KAAKL,SAAL,CAAemB,GAAf,CAAmBd,KAAnB,IAA4B,KAAKL,SAAL,CAAeoB,GAAf,CAAmBf,KAAnB,EAA0BgB,MAAtD,GAA+D,CAAtE;AACH;;AA9Fc;;AAgGnB3B,OAAO,CAACE,YAAR,GAAuBA,YAAvB","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventEmitter = void 0;\nconst index_js_1 = __importDefault(require(\"../../vendor/mitt/src/index.js\"));\n/**\n * The EventEmitter class that many Puppeteer classes extend.\n *\n * @remarks\n *\n * This allows you to listen to events that Puppeteer classes fire and act\n * accordingly. Therefore you'll mostly use {@link EventEmitter.on | on} and\n * {@link EventEmitter.off | off} to bind\n * and unbind to event listeners.\n *\n * @public\n */\nclass EventEmitter {\n    /**\n     * @internal\n     */\n    constructor() {\n        this.eventsMap = new Map();\n        this.emitter = index_js_1.default(this.eventsMap);\n    }\n    /**\n     * Bind an event listener to fire when an event occurs.\n     * @param event - the event type you'd like to listen to. Can be a string or symbol.\n     * @param handler  - the function to be called when the event occurs.\n     * @returns `this` to enable you to chain calls.\n     */\n    on(event, handler) {\n        this.emitter.on(event, handler);\n        return this;\n    }\n    /**\n     * Remove an event listener from firing.\n     * @param event - the event type you'd like to stop listening to.\n     * @param handler  - the function that should be removed.\n     * @returns `this` to enable you to chain calls.\n     */\n    off(event, handler) {\n        this.emitter.off(event, handler);\n        return this;\n    }\n    /**\n     * Remove an event listener.\n     * @deprecated please use `off` instead.\n     */\n    removeListener(event, handler) {\n        this.off(event, handler);\n        return this;\n    }\n    /**\n     * Add an event listener.\n     * @deprecated please use `on` instead.\n     */\n    addListener(event, handler) {\n        this.on(event, handler);\n        return this;\n    }\n    /**\n     * Emit an event and call any associated listeners.\n     *\n     * @param event - the event you'd like to emit\n     * @param eventData - any data you'd like to emit with the event\n     * @returns `true` if there are any listeners, `false` if there are not.\n     */\n    emit(event, eventData) {\n        this.emitter.emit(event, eventData);\n        return this.eventListenersCount(event) > 0;\n    }\n    /**\n     * Like `on` but the listener will only be fired once and then it will be removed.\n     * @param event - the event you'd like to listen to\n     * @param handler - the handler function to run when the event occurs\n     * @returns `this` to enable you to chain calls.\n     */\n    once(event, handler) {\n        const onceHandler = (eventData) => {\n            handler(eventData);\n            this.off(event, onceHandler);\n        };\n        return this.on(event, onceHandler);\n    }\n    /**\n     * Gets the number of listeners for a given event.\n     *\n     * @param event - the event to get the listener count for\n     * @returns the number of listeners bound to the given event\n     */\n    listenerCount(event) {\n        return this.eventListenersCount(event);\n    }\n    /**\n     * Removes all listeners. If given an event argument, it will remove only\n     * listeners for that event.\n     * @param event - the event to remove listeners for.\n     * @returns `this` to enable you to chain calls.\n     */\n    removeAllListeners(event) {\n        if (event) {\n            this.eventsMap.delete(event);\n        }\n        else {\n            this.eventsMap.clear();\n        }\n        return this;\n    }\n    eventListenersCount(event) {\n        return this.eventsMap.has(event) ? this.eventsMap.get(event).length : 0;\n    }\n}\nexports.EventEmitter = EventEmitter;\n"]},"metadata":{},"sourceType":"script"}