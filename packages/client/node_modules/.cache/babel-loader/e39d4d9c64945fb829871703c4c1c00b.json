{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Frame = exports.FrameManager = exports.FrameManagerEmittedEvents = void 0;\n\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\n\nconst LifecycleWatcher_js_1 = require(\"./LifecycleWatcher.js\");\n\nconst DOMWorld_js_1 = require(\"./DOMWorld.js\");\n\nconst NetworkManager_js_1 = require(\"./NetworkManager.js\");\n\nconst UTILITY_WORLD_NAME = '__puppeteer_utility_world__';\n/**\n * We use symbols to prevent external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\n\nexports.FrameManagerEmittedEvents = {\n  FrameAttached: Symbol('FrameManager.FrameAttached'),\n  FrameNavigated: Symbol('FrameManager.FrameNavigated'),\n  FrameDetached: Symbol('FrameManager.FrameDetached'),\n  LifecycleEvent: Symbol('FrameManager.LifecycleEvent'),\n  FrameNavigatedWithinDocument: Symbol('FrameManager.FrameNavigatedWithinDocument'),\n  ExecutionContextCreated: Symbol('FrameManager.ExecutionContextCreated'),\n  ExecutionContextDestroyed: Symbol('FrameManager.ExecutionContextDestroyed')\n};\n/**\n * @internal\n */\n\nclass FrameManager extends EventEmitter_js_1.EventEmitter {\n  constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {\n    super();\n    this._frames = new Map();\n    this._contextIdToContext = new Map();\n    this._isolatedWorlds = new Set();\n    this._client = client;\n    this._page = page;\n    this._networkManager = new NetworkManager_js_1.NetworkManager(client, ignoreHTTPSErrors, this);\n    this._timeoutSettings = timeoutSettings;\n\n    this._client.on('Page.frameAttached', event => this._onFrameAttached(event.frameId, event.parentFrameId));\n\n    this._client.on('Page.frameNavigated', event => this._onFrameNavigated(event.frame));\n\n    this._client.on('Page.navigatedWithinDocument', event => this._onFrameNavigatedWithinDocument(event.frameId, event.url));\n\n    this._client.on('Page.frameDetached', event => this._onFrameDetached(event.frameId));\n\n    this._client.on('Page.frameStoppedLoading', event => this._onFrameStoppedLoading(event.frameId));\n\n    this._client.on('Runtime.executionContextCreated', event => this._onExecutionContextCreated(event.context));\n\n    this._client.on('Runtime.executionContextDestroyed', event => this._onExecutionContextDestroyed(event.executionContextId));\n\n    this._client.on('Runtime.executionContextsCleared', () => this._onExecutionContextsCleared());\n\n    this._client.on('Page.lifecycleEvent', event => this._onLifecycleEvent(event));\n  }\n\n  async initialize() {\n    const result = await Promise.all([this._client.send('Page.enable'), this._client.send('Page.getFrameTree')]);\n    const {\n      frameTree\n    } = result[1];\n\n    this._handleFrameTree(frameTree);\n\n    await Promise.all([this._client.send('Page.setLifecycleEventsEnabled', {\n      enabled: true\n    }), this._client.send('Runtime.enable').then(() => this._ensureIsolatedWorld(UTILITY_WORLD_NAME)), this._networkManager.initialize()]);\n  }\n\n  networkManager() {\n    return this._networkManager;\n  }\n\n  async navigateFrame(frame, url, options = {}) {\n    assertNoLegacyNavigationOptions(options);\n    const {\n      referer = this._networkManager.extraHTTPHeaders()['referer'],\n      waitUntil = ['load'],\n      timeout = this._timeoutSettings.navigationTimeout()\n    } = options;\n    const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this, frame, waitUntil, timeout);\n    let ensureNewDocumentNavigation = false;\n    let error = await Promise.race([navigate(this._client, url, referer, frame._id), watcher.timeoutOrTerminationPromise()]);\n\n    if (!error) {\n      error = await Promise.race([watcher.timeoutOrTerminationPromise(), ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()]);\n    }\n\n    watcher.dispose();\n    if (error) throw error;\n    return watcher.navigationResponse();\n\n    async function navigate(client, url, referrer, frameId) {\n      try {\n        const response = await client.send('Page.navigate', {\n          url,\n          referrer,\n          frameId\n        });\n        ensureNewDocumentNavigation = !!response.loaderId;\n        return response.errorText ? new Error(`${response.errorText} at ${url}`) : null;\n      } catch (error) {\n        return error;\n      }\n    }\n  }\n\n  async waitForFrameNavigation(frame, options = {}) {\n    assertNoLegacyNavigationOptions(options);\n    const {\n      waitUntil = ['load'],\n      timeout = this._timeoutSettings.navigationTimeout()\n    } = options;\n    const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this, frame, waitUntil, timeout);\n    const error = await Promise.race([watcher.timeoutOrTerminationPromise(), watcher.sameDocumentNavigationPromise(), watcher.newDocumentNavigationPromise()]);\n    watcher.dispose();\n    if (error) throw error;\n    return watcher.navigationResponse();\n  }\n\n  _onLifecycleEvent(event) {\n    const frame = this._frames.get(event.frameId);\n\n    if (!frame) return;\n\n    frame._onLifecycleEvent(event.loaderId, event.name);\n\n    this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);\n  }\n\n  _onFrameStoppedLoading(frameId) {\n    const frame = this._frames.get(frameId);\n\n    if (!frame) return;\n\n    frame._onLoadingStopped();\n\n    this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);\n  }\n\n  _handleFrameTree(frameTree) {\n    if (frameTree.frame.parentId) this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId);\n\n    this._onFrameNavigated(frameTree.frame);\n\n    if (!frameTree.childFrames) return;\n\n    for (const child of frameTree.childFrames) this._handleFrameTree(child);\n  }\n\n  page() {\n    return this._page;\n  }\n\n  mainFrame() {\n    return this._mainFrame;\n  }\n\n  frames() {\n    return Array.from(this._frames.values());\n  }\n\n  frame(frameId) {\n    return this._frames.get(frameId) || null;\n  }\n\n  _onFrameAttached(frameId, parentFrameId) {\n    if (this._frames.has(frameId)) return;\n    assert_js_1.assert(parentFrameId);\n\n    const parentFrame = this._frames.get(parentFrameId);\n\n    const frame = new Frame(this, parentFrame, frameId);\n\n    this._frames.set(frame._id, frame);\n\n    this.emit(exports.FrameManagerEmittedEvents.FrameAttached, frame);\n  }\n\n  _onFrameNavigated(framePayload) {\n    const isMainFrame = !framePayload.parentId;\n    let frame = isMainFrame ? this._mainFrame : this._frames.get(framePayload.id);\n    assert_js_1.assert(isMainFrame || frame, 'We either navigate top level or have old version of the navigated frame'); // Detach all child frames first.\n\n    if (frame) {\n      for (const child of frame.childFrames()) this._removeFramesRecursively(child);\n    } // Update or create main frame.\n\n\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frames.delete(frame._id);\n\n        frame._id = framePayload.id;\n      } else {\n        // Initial main frame navigation.\n        frame = new Frame(this, null, framePayload.id);\n      }\n\n      this._frames.set(framePayload.id, frame);\n\n      this._mainFrame = frame;\n    } // Update frame payload.\n\n\n    frame._navigated(framePayload);\n\n    this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);\n  }\n\n  async _ensureIsolatedWorld(name) {\n    if (this._isolatedWorlds.has(name)) return;\n\n    this._isolatedWorlds.add(name);\n\n    await this._client.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: `//# sourceURL=${ExecutionContext_js_1.EVALUATION_SCRIPT_URL}`,\n      worldName: name\n    }), await Promise.all(this.frames().map(frame => this._client.send('Page.createIsolatedWorld', {\n      frameId: frame._id,\n      grantUniveralAccess: true,\n      worldName: name\n    }).catch(helper_js_1.debugError))); // frames might be removed before we send this\n  }\n\n  _onFrameNavigatedWithinDocument(frameId, url) {\n    const frame = this._frames.get(frameId);\n\n    if (!frame) return;\n\n    frame._navigatedWithinDocument(url);\n\n    this.emit(exports.FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);\n    this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);\n  }\n\n  _onFrameDetached(frameId) {\n    const frame = this._frames.get(frameId);\n\n    if (frame) this._removeFramesRecursively(frame);\n  }\n\n  _onExecutionContextCreated(contextPayload) {\n    const auxData = contextPayload.auxData;\n    const frameId = auxData ? auxData.frameId : null;\n    const frame = this._frames.get(frameId) || null;\n    let world = null;\n\n    if (frame) {\n      if (contextPayload.auxData && !!contextPayload.auxData['isDefault']) {\n        world = frame._mainWorld;\n      } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame._secondaryWorld._hasContext()) {\n        // In case of multiple sessions to the same target, there's a race between\n        // connections so we might end up creating multiple isolated worlds.\n        // We can use either.\n        world = frame._secondaryWorld;\n      }\n    }\n\n    if (contextPayload.auxData && contextPayload.auxData['type'] === 'isolated') this._isolatedWorlds.add(contextPayload.name);\n    const context = new ExecutionContext_js_1.ExecutionContext(this._client, contextPayload, world);\n    if (world) world._setContext(context);\n\n    this._contextIdToContext.set(contextPayload.id, context);\n  }\n\n  _onExecutionContextDestroyed(executionContextId) {\n    const context = this._contextIdToContext.get(executionContextId);\n\n    if (!context) return;\n\n    this._contextIdToContext.delete(executionContextId);\n\n    if (context._world) context._world._setContext(null);\n  }\n\n  _onExecutionContextsCleared() {\n    for (const context of this._contextIdToContext.values()) {\n      if (context._world) context._world._setContext(null);\n    }\n\n    this._contextIdToContext.clear();\n  }\n\n  executionContextById(contextId) {\n    const context = this._contextIdToContext.get(contextId);\n\n    assert_js_1.assert(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n    return context;\n  }\n\n  _removeFramesRecursively(frame) {\n    for (const child of frame.childFrames()) this._removeFramesRecursively(child);\n\n    frame._detach();\n\n    this._frames.delete(frame._id);\n\n    this.emit(exports.FrameManagerEmittedEvents.FrameDetached, frame);\n  }\n\n}\n\nexports.FrameManager = FrameManager;\n/**\n * At every point of time, page exposes its current frame tree via the\n * {@link Page.mainFrame | page.mainFrame} and\n * {@link Frame.childFrames | frame.childFrames} methods.\n *\n * @remarks\n *\n * `Frame` object lifecycles are controlled by three events that are all\n * dispatched on the page object:\n *\n * - {@link PageEmittedEvents.FrameAttached}\n *\n * - {@link PageEmittedEvents.FrameNavigated}\n *\n * - {@link PageEmittedEvents.FrameDetached}\n *\n * @Example\n * An example of dumping frame tree:\n *\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://www.google.com/chrome/browser/canary.html');\n *   dumpFrameTree(page.mainFrame(), '');\n *   await browser.close();\n *\n *   function dumpFrameTree(frame, indent) {\n *     console.log(indent + frame.url());\n *     for (const child of frame.childFrames()) {\n *     dumpFrameTree(child, indent + '  ');\n *     }\n *   }\n * })();\n * ```\n *\n * @Example\n * An example of getting text from an iframe element:\n *\n * ```js\n * const frame = page.frames().find(frame => frame.name() === 'myframe');\n * const text = await frame.$eval('.selector', element => element.textContent);\n * console.log(text);\n * ```\n *\n * @public\n */\n\nclass Frame {\n  /**\n   * @internal\n   */\n  constructor(frameManager, parentFrame, frameId) {\n    this._url = '';\n    this._detached = false;\n    /**\n     * @internal\n     */\n\n    this._loaderId = '';\n    /**\n     * @internal\n     */\n\n    this._lifecycleEvents = new Set();\n    this._frameManager = frameManager;\n    this._parentFrame = parentFrame;\n    this._url = '';\n    this._id = frameId;\n    this._detached = false;\n    this._loaderId = '';\n    this._mainWorld = new DOMWorld_js_1.DOMWorld(frameManager, this, frameManager._timeoutSettings);\n    this._secondaryWorld = new DOMWorld_js_1.DOMWorld(frameManager, this, frameManager._timeoutSettings);\n    this._childFrames = new Set();\n    if (this._parentFrame) this._parentFrame._childFrames.add(this);\n  }\n  /**\n   * @remarks\n   *\n   * `frame.goto` will throw an error if:\n   * - there's an SSL error (e.g. in case of self-signed certificates).\n   *\n   * - target URL is invalid.\n   *\n   * - the `timeout` is exceeded during navigation.\n   *\n   * - the remote server does not respond or is unreachable.\n   *\n   * - the main resource failed to load.\n   *\n   * `frame.goto` will not throw an error when any valid HTTP status code is\n   * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n   * Server Error\".  The status code for such responses can be retrieved by\n   * calling {@link HTTPResponse.status}.\n   *\n   * NOTE: `frame.goto` either throws an error or returns a main resource\n   * response. The only exceptions are navigation to `about:blank` or\n   * navigation to the same URL with a different hash, which would succeed and\n   * return `null`.\n   *\n   * NOTE: Headless mode doesn't support navigation to a PDF document. See\n   * the {@link https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n   * issue}.\n   *\n   * @param url - the URL to navigate the frame to. This should include the\n   * scheme, e.g. `https://`.\n   * @param options - navigation options. `waitUntil` is useful to define when\n   * the navigation should be considered successful - see the docs for\n   * {@link PuppeteerLifeCycleEvent} for more details.\n   *\n   * @returns A promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   */\n\n\n  async goto(url, options = {}) {\n    return await this._frameManager.navigateFrame(this, url, options);\n  }\n  /**\n   * @remarks\n   *\n   * This resolves when the frame navigates to a new URL. It is useful for when\n   * you run code which will indirectly cause the frame to navigate. Consider\n   * this example:\n   *\n   * ```js\n   * const [response] = await Promise.all([\n   *   // The navigation promise resolves after navigation has finished\n   *   frame.waitForNavigation(),\n   *   // Clicking the link will indirectly cause a navigation\n   *   frame.click('a.my-link'),\n   * ]);\n   * ```\n   *\n   * Usage of the {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API} to change the URL is considered a navigation.\n   *\n   * @param options - options to configure when the navigation is consided finished.\n   * @returns a promise that resolves when the frame navigates to a new URL.\n   */\n\n\n  async waitForNavigation(options = {}) {\n    return await this._frameManager.waitForFrameNavigation(this, options);\n  }\n  /**\n   * @returns a promise that resolves to the frame's default execution context.\n   */\n\n\n  executionContext() {\n    return this._mainWorld.executionContext();\n  }\n  /**\n   * @remarks\n   *\n   * The only difference between {@link Frame.evaluate} and\n   * `frame.evaluateHandle` is that `evaluateHandle` will return the value\n   * wrapped in an in-page object.\n   *\n   * This method behaves identically to {@link Page.evaluateHandle} except it's\n   * run within the context of the `frame`, rather than the entire page.\n   *\n   * @param pageFunction - a function that is run within the frame\n   * @param args - arguments to be passed to the pageFunction\n   */\n\n\n  async evaluateHandle(pageFunction, ...args) {\n    return this._mainWorld.evaluateHandle(pageFunction, ...args);\n  }\n  /**\n   * @remarks\n   *\n   * This method behaves identically to {@link Page.evaluate} except it's run\n   * within the context of the `frame`, rather than the entire page.\n   *\n   * @param pageFunction - a function that is run within the frame\n   * @param args - arguments to be passed to the pageFunction\n   */\n\n\n  async evaluate(pageFunction, ...args) {\n    return this._mainWorld.evaluate(pageFunction, ...args);\n  }\n  /**\n   * This method queries the frame for the given selector.\n   *\n   * @param selector - a selector to query for.\n   * @returns A promise which resolves to an `ElementHandle` pointing at the\n   * element, or `null` if it was not found.\n   */\n\n\n  async $(selector) {\n    return this._mainWorld.$(selector);\n  }\n  /**\n   * This method evaluates the given XPath expression and returns the results.\n   *\n   * @param expression - the XPath expression to evaluate.\n   */\n\n\n  async $x(expression) {\n    return this._mainWorld.$x(expression);\n  }\n  /**\n   * @remarks\n   *\n   * This method runs `document.querySelector` within\n   * the frame and passes it as the first argument to `pageFunction`.\n   *\n   * If `pageFunction` returns a Promise, then `frame.$eval` would wait for\n   * the promise to resolve and return its value.\n   *\n   * @example\n   *\n   * ```js\n   * const searchValue = await frame.$eval('#search', el => el.value);\n   * ```\n   *\n   * @param selector - the selector to query for\n   * @param pageFunction - the function to be evaluated in the frame's context\n   * @param args - additional arguments to pass to `pageFuncton`\n   */\n\n\n  async $eval(selector, pageFunction, ...args) {\n    return this._mainWorld.$eval(selector, pageFunction, ...args);\n  }\n  /**\n   * @remarks\n   *\n   * This method runs `Array.from(document.querySelectorAll(selector))` within\n   * the frame and passes it as the first argument to `pageFunction`.\n   *\n   * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for\n   * the promise to resolve and return its value.\n   *\n   * @example\n   *\n   * ```js\n   * const divsCounts = await frame.$$eval('div', divs => divs.length);\n   * ```\n   *\n   * @param selector - the selector to query for\n   * @param pageFunction - the function to be evaluated in the frame's context\n   * @param args - additional arguments to pass to `pageFuncton`\n   */\n\n\n  async $$eval(selector, pageFunction, ...args) {\n    return this._mainWorld.$$eval(selector, pageFunction, ...args);\n  }\n  /**\n   * This runs `document.querySelectorAll` in the frame and returns the result.\n   *\n   * @param selector - a selector to search for\n   * @returns An array of element handles pointing to the found frame elements.\n   */\n\n\n  async $$(selector) {\n    return this._mainWorld.$$(selector);\n  }\n  /**\n   * @returns the full HTML contents of the frame, including the doctype.\n   */\n\n\n  async content() {\n    return this._secondaryWorld.content();\n  }\n  /**\n   * Set the content of the frame.\n   *\n   * @param html - HTML markup to assign to the page.\n   * @param options - options to configure how long before timing out and at\n   * what point to consider the content setting successful.\n   */\n\n\n  async setContent(html, options = {}) {\n    return this._secondaryWorld.setContent(html, options);\n  }\n  /**\n   * @remarks\n   *\n   * If the name is empty, it returns the `id` attribute instead.\n   *\n   * Note: This value is calculated once when the frame is created, and will not\n   * update if the attribute is changed later.\n   *\n   * @returns the frame's `name` attribute as specified in the tag.\n   */\n\n\n  name() {\n    return this._name || '';\n  }\n  /**\n   * @returns the frame's URL.\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * @returns the parent `Frame`, if any. Detached and main frames return `null`.\n   */\n\n\n  parentFrame() {\n    return this._parentFrame;\n  }\n  /**\n   * @returns an array of child frames.\n   */\n\n\n  childFrames() {\n    return Array.from(this._childFrames);\n  }\n  /**\n   * @returns `true` if the frame has been detached, or `false` otherwise.\n   */\n\n\n  isDetached() {\n    return this._detached;\n  }\n  /**\n   * Adds a `<script>` tag into the page with the desired url or content.\n   *\n   * @param options - configure the script to add to the page.\n   *\n   * @returns a promise that resolves to the added tag when the script's\n   * `onload` event fires or when the script content was injected into the\n   * frame.\n   */\n\n\n  async addScriptTag(options) {\n    return this._mainWorld.addScriptTag(options);\n  }\n  /**\n   * Adds a `<link rel=\"stylesheet\">` tag into the page with the desired url or\n   * a `<style type=\"text/css\">` tag with the content.\n   *\n   * @param options - configure the CSS to add to the page.\n   *\n   * @returns a promise that resolves to the added tag when the stylesheets's\n   * `onload` event fires or when the CSS content was injected into the\n   * frame.\n   */\n\n\n  async addStyleTag(options) {\n    return this._mainWorld.addStyleTag(options);\n  }\n  /**\n   *\n   * This method clicks the first element found that matches `selector`.\n   *\n   * @remarks\n   *\n   * This method scrolls the element into view if needed, and then uses\n   * {@link Page.mouse} to click in the center of the element. If there's no\n   * element matching `selector`, the method throws an error.\n   *\n   * Bear in mind that if `click()` triggers a navigation event and there's a\n   * separate `page.waitForNavigation()` promise to be resolved, you may end up\n   * with a race condition that yields unexpected results. The correct pattern\n   * for click and wait for navigation is the following:\n   *\n   * ```javascript\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(waitOptions),\n   *   frame.click(selector, clickOptions),\n   * ]);\n   * ```\n   * @param selector - the selector to search for to click. If there are\n   * multiple elements, the first will be clicked.\n   */\n\n\n  async click(selector, options = {}) {\n    return this._secondaryWorld.click(selector, options);\n  }\n  /**\n   * This method fetches an element with `selector` and focuses it.\n   *\n   * @remarks\n   * If there's no element matching `selector`, the method throws an error.\n   *\n   * @param selector - the selector for the element to focus. If there are\n   * multiple elements, the first will be focused.\n   */\n\n\n  async focus(selector) {\n    return this._secondaryWorld.focus(selector);\n  }\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page.mouse} to hover over the center of the\n   * element.\n   *\n   * @remarks\n   * If there's no element matching `selector`, the method throws an\n   *\n   * @param selector - the selector for the element to hover. If there are\n   * multiple elements, the first will be hovered.\n   */\n\n\n  async hover(selector) {\n    return this._secondaryWorld.hover(selector);\n  }\n  /**\n   * Triggers a `change` and `input` event once all the provided options have\n   * been selected.\n   *\n   * @remarks\n   *\n   * If there's no `<select>` element matching `selector`, the\n   * method throws an error.\n   *\n   * @example\n   * ```js\n   * frame.select('select#colors', 'blue'); // single selection\n   * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param selector - a selector to query the frame for\n   * @param values - an array of values to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first\n   * one is taken into account.\n   * @returns the list of values that were successfully selected.\n   */\n\n\n  select(selector, ...values) {\n    return this._secondaryWorld.select(selector, ...values);\n  }\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page.touchscreen} to tap in the center of the\n   * element.\n   *\n   * @remarks\n   *\n   * If there's no element matching `selector`, the method throws an error.\n   *\n   * @param selector - the selector to tap.\n   * @returns a promise that resolves when the element has been tapped.\n   */\n\n\n  async tap(selector) {\n    return this._secondaryWorld.tap(selector);\n  }\n  /**\n   * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character\n   * in the text.\n   *\n   * @remarks\n   * To press a special key, like `Control` or `ArrowDown`, use\n   * {@link Keyboard.press}.\n   *\n   * @example\n   * ```js\n   * await frame.type('#mytextarea', 'Hello'); // Types instantly\n   * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user\n   * ```\n   *\n   * @param selector - the selector for the element to type into. If there are\n   * multiple the first will be used.\n   * @param text - text to type into the element\n   * @param options - takes one option, `delay`, which sets the time to wait\n   * between key presses in milliseconds. Defaults to `0`.\n   *\n   * @returns a promise that resolves when the typing is complete.\n   */\n\n\n  async type(selector, text, options) {\n    return this._mainWorld.type(selector, text, options);\n  }\n  /**\n   * @remarks\n   *\n   * This method behaves differently depending on the first parameter. If it's a\n   * `string`, it will be treated as a `selector` or `xpath` (if the string\n   * starts with `//`). This method then is a shortcut for\n   * {@link Frame.waitForSelector} or {@link Frame.waitForXPath}.\n   *\n   * If the first argument is a function this method is a shortcut for\n   * {@link Frame.waitForFunction}.\n   *\n   * If the first argument is a `number`, it's treated as a timeout in\n   * milliseconds and the method returns a promise which resolves after the\n   * timeout.\n   *\n   * @param selectorOrFunctionOrTimeout - a selector, predicate or timeout to\n   * wait for.\n   * @param options - optional waiting parameters.\n   * @param args - arguments to pass to `pageFunction`.\n   *\n   * @deprecated Don't use this method directly. Instead use the more explicit\n   * methods available: {@link Frame.waitForSelector},\n   * {@link Frame.waitForXPath}, {@link Frame.waitForFunction} or\n   * {@link Frame.waitForTimeout}.\n   */\n\n\n  waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {\n    const xPathPattern = '//';\n    console.warn('waitFor is deprecated and will be removed in a future release. See https://github.com/puppeteer/puppeteer/issues/6214 for details and how to migrate your code.');\n\n    if (helper_js_1.helper.isString(selectorOrFunctionOrTimeout)) {\n      const string = selectorOrFunctionOrTimeout;\n      if (string.startsWith(xPathPattern)) return this.waitForXPath(string, options);\n      return this.waitForSelector(string, options);\n    }\n\n    if (helper_js_1.helper.isNumber(selectorOrFunctionOrTimeout)) return new Promise(fulfill => setTimeout(fulfill, selectorOrFunctionOrTimeout));\n    if (typeof selectorOrFunctionOrTimeout === 'function') return this.waitForFunction(selectorOrFunctionOrTimeout, options, ...args);\n    return Promise.reject(new Error('Unsupported target type: ' + typeof selectorOrFunctionOrTimeout));\n  }\n  /**\n   * Causes your script to wait for the given number of milliseconds.\n   *\n   * @remarks\n   * It's generally recommended to not wait for a number of seconds, but instead\n   * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n   * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n   *\n   * @example\n   *\n   * Wait for 1 second:\n   *\n   * ```\n   * await frame.waitForTimeout(1000);\n   * ```\n   *\n   * @param milliseconds - the number of milliseconds to wait.\n   */\n\n\n  waitForTimeout(milliseconds) {\n    return new Promise(resolve => {\n      setTimeout(resolve, milliseconds);\n    });\n  }\n  /**\n   * @remarks\n   *\n   *\n   * Wait for the `selector` to appear in page. If at the moment of calling the\n   * method the `selector` already exists, the method will return immediately.\n   * If the selector doesn't appear after the `timeout` milliseconds of waiting,\n   * the function will throw.\n   *\n   * This method works across navigations.\n   *\n   * @example\n   * ```js\n   * const puppeteer = require('puppeteer');\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page.mainFrame()\n   *   .waitForSelector('img')\n   *   .then(() => console.log('First URL with image: ' + currentURL));\n   *\n   *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com']) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   * @param selector - the selector to wait for.\n   * @param options - options to define if the element should be visible and how\n   * long to wait before timing out.\n   * @returns a promise which resolves when an element matching the selector\n   * string is added to the DOM.\n   */\n\n\n  async waitForSelector(selector, options = {}) {\n    const handle = await this._secondaryWorld.waitForSelector(selector, options);\n    if (!handle) return null;\n    const mainExecutionContext = await this._mainWorld.executionContext();\n    const result = await mainExecutionContext._adoptElementHandle(handle);\n    await handle.dispose();\n    return result;\n  }\n  /**\n   * @remarks\n   * Wait for the `xpath` to appear in page. If at the moment of calling the\n   * method the `xpath` already exists, the method will return immediately. If\n   * the xpath doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * For a code example, see the example for {@link Frame.waitForSelector}. That\n   * function behaves identically other than taking a CSS selector rather than\n   * an XPath.\n   *\n   * @param xpath - the XPath expression to wait for.\n   * @param options  - options to configure the visiblity of the element and how\n   * long to wait before timing out.\n   */\n\n\n  async waitForXPath(xpath, options = {}) {\n    const handle = await this._secondaryWorld.waitForXPath(xpath, options);\n    if (!handle) return null;\n    const mainExecutionContext = await this._mainWorld.executionContext();\n    const result = await mainExecutionContext._adoptElementHandle(handle);\n    await handle.dispose();\n    return result;\n  }\n  /**\n   * @remarks\n   *\n   * @example\n   *\n   * The `waitForFunction` can be used to observe viewport size change:\n   * ```js\n   * const puppeteer = require('puppeteer');\n   *\n   * (async () => {\n   * .  const browser = await puppeteer.launch();\n   * .  const page = await browser.newPage();\n   * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');\n   * .  page.setViewport({width: 50, height: 50});\n   * .  await watchDog;\n   * .  await browser.close();\n   * })();\n   * ```\n   *\n   * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:\n   *\n   * ```js\n   * const selector = '.foo';\n   * await frame.waitForFunction(\n   *   selector => !!document.querySelector(selector),\n   *   {}, // empty options object\n   *   selector\n   *);\n   * ```\n   *\n   * @param pageFunction - the function to evaluate in the frame context.\n   * @param options - options to configure the polling method and timeout.\n   * @param args - arguments to pass to the `pageFunction`.\n   * @returns the promise which resolve when the `pageFunction` returns a truthy value.\n   */\n\n\n  waitForFunction(pageFunction, options = {}, ...args) {\n    return this._mainWorld.waitForFunction(pageFunction, options, ...args);\n  }\n  /**\n   * @returns the frame's title.\n   */\n\n\n  async title() {\n    return this._secondaryWorld.title();\n  }\n  /**\n   * @internal\n   */\n\n\n  _navigated(framePayload) {\n    this._name = framePayload.name;\n    this._url = `${framePayload.url}${framePayload.urlFragment || ''}`;\n  }\n  /**\n   * @internal\n   */\n\n\n  _navigatedWithinDocument(url) {\n    this._url = url;\n  }\n  /**\n   * @internal\n   */\n\n\n  _onLifecycleEvent(loaderId, name) {\n    if (name === 'init') {\n      this._loaderId = loaderId;\n\n      this._lifecycleEvents.clear();\n    }\n\n    this._lifecycleEvents.add(name);\n  }\n  /**\n   * @internal\n   */\n\n\n  _onLoadingStopped() {\n    this._lifecycleEvents.add('DOMContentLoaded');\n\n    this._lifecycleEvents.add('load');\n  }\n  /**\n   * @internal\n   */\n\n\n  _detach() {\n    this._detached = true;\n\n    this._mainWorld._detach();\n\n    this._secondaryWorld._detach();\n\n    if (this._parentFrame) this._parentFrame._childFrames.delete(this);\n    this._parentFrame = null;\n  }\n\n}\n\nexports.Frame = Frame;\n\nfunction assertNoLegacyNavigationOptions(options) {\n  assert_js_1.assert(options['networkIdleTimeout'] === undefined, 'ERROR: networkIdleTimeout option is no longer supported.');\n  assert_js_1.assert(options['networkIdleInflight'] === undefined, 'ERROR: networkIdleInflight option is no longer supported.');\n  assert_js_1.assert(options.waitUntil !== 'networkidle', 'ERROR: \"networkidle\" option is no longer supported. Use \"networkidle2\" instead');\n}","map":{"version":3,"sources":["C:/Users/Sajjad Brohi/JavaScript Projects/RESTful API/packages/client/node_modules/puppeteer/lib/cjs/puppeteer/common/FrameManager.js"],"names":["Object","defineProperty","exports","value","Frame","FrameManager","FrameManagerEmittedEvents","EventEmitter_js_1","require","assert_js_1","helper_js_1","ExecutionContext_js_1","LifecycleWatcher_js_1","DOMWorld_js_1","NetworkManager_js_1","UTILITY_WORLD_NAME","FrameAttached","Symbol","FrameNavigated","FrameDetached","LifecycleEvent","FrameNavigatedWithinDocument","ExecutionContextCreated","ExecutionContextDestroyed","EventEmitter","constructor","client","page","ignoreHTTPSErrors","timeoutSettings","_frames","Map","_contextIdToContext","_isolatedWorlds","Set","_client","_page","_networkManager","NetworkManager","_timeoutSettings","on","event","_onFrameAttached","frameId","parentFrameId","_onFrameNavigated","frame","_onFrameNavigatedWithinDocument","url","_onFrameDetached","_onFrameStoppedLoading","_onExecutionContextCreated","context","_onExecutionContextDestroyed","executionContextId","_onExecutionContextsCleared","_onLifecycleEvent","initialize","result","Promise","all","send","frameTree","_handleFrameTree","enabled","then","_ensureIsolatedWorld","networkManager","navigateFrame","options","assertNoLegacyNavigationOptions","referer","extraHTTPHeaders","waitUntil","timeout","navigationTimeout","watcher","LifecycleWatcher","ensureNewDocumentNavigation","error","race","navigate","_id","timeoutOrTerminationPromise","newDocumentNavigationPromise","sameDocumentNavigationPromise","dispose","navigationResponse","referrer","response","loaderId","errorText","Error","waitForFrameNavigation","get","name","emit","_onLoadingStopped","parentId","id","childFrames","child","mainFrame","_mainFrame","frames","Array","from","values","has","assert","parentFrame","set","framePayload","isMainFrame","_removeFramesRecursively","delete","_navigated","add","source","EVALUATION_SCRIPT_URL","worldName","map","grantUniveralAccess","catch","debugError","_navigatedWithinDocument","contextPayload","auxData","world","_mainWorld","_secondaryWorld","_hasContext","ExecutionContext","_setContext","_world","clear","executionContextById","contextId","_detach","frameManager","_url","_detached","_loaderId","_lifecycleEvents","_frameManager","_parentFrame","DOMWorld","_childFrames","goto","waitForNavigation","executionContext","evaluateHandle","pageFunction","args","evaluate","$","selector","$x","expression","$eval","$$eval","$$","content","setContent","html","_name","isDetached","addScriptTag","addStyleTag","click","focus","hover","select","tap","type","text","waitFor","selectorOrFunctionOrTimeout","xPathPattern","console","warn","helper","isString","string","startsWith","waitForXPath","waitForSelector","isNumber","fulfill","setTimeout","waitForFunction","reject","waitForTimeout","milliseconds","resolve","handle","mainExecutionContext","_adoptElementHandle","xpath","title","urlFragment","undefined"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Frame = exports.FrameManager = exports.FrameManagerEmittedEvents = void 0;\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\nconst LifecycleWatcher_js_1 = require(\"./LifecycleWatcher.js\");\nconst DOMWorld_js_1 = require(\"./DOMWorld.js\");\nconst NetworkManager_js_1 = require(\"./NetworkManager.js\");\nconst UTILITY_WORLD_NAME = '__puppeteer_utility_world__';\n/**\n * We use symbols to prevent external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexports.FrameManagerEmittedEvents = {\n    FrameAttached: Symbol('FrameManager.FrameAttached'),\n    FrameNavigated: Symbol('FrameManager.FrameNavigated'),\n    FrameDetached: Symbol('FrameManager.FrameDetached'),\n    LifecycleEvent: Symbol('FrameManager.LifecycleEvent'),\n    FrameNavigatedWithinDocument: Symbol('FrameManager.FrameNavigatedWithinDocument'),\n    ExecutionContextCreated: Symbol('FrameManager.ExecutionContextCreated'),\n    ExecutionContextDestroyed: Symbol('FrameManager.ExecutionContextDestroyed'),\n};\n/**\n * @internal\n */\nclass FrameManager extends EventEmitter_js_1.EventEmitter {\n    constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {\n        super();\n        this._frames = new Map();\n        this._contextIdToContext = new Map();\n        this._isolatedWorlds = new Set();\n        this._client = client;\n        this._page = page;\n        this._networkManager = new NetworkManager_js_1.NetworkManager(client, ignoreHTTPSErrors, this);\n        this._timeoutSettings = timeoutSettings;\n        this._client.on('Page.frameAttached', (event) => this._onFrameAttached(event.frameId, event.parentFrameId));\n        this._client.on('Page.frameNavigated', (event) => this._onFrameNavigated(event.frame));\n        this._client.on('Page.navigatedWithinDocument', (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url));\n        this._client.on('Page.frameDetached', (event) => this._onFrameDetached(event.frameId));\n        this._client.on('Page.frameStoppedLoading', (event) => this._onFrameStoppedLoading(event.frameId));\n        this._client.on('Runtime.executionContextCreated', (event) => this._onExecutionContextCreated(event.context));\n        this._client.on('Runtime.executionContextDestroyed', (event) => this._onExecutionContextDestroyed(event.executionContextId));\n        this._client.on('Runtime.executionContextsCleared', () => this._onExecutionContextsCleared());\n        this._client.on('Page.lifecycleEvent', (event) => this._onLifecycleEvent(event));\n    }\n    async initialize() {\n        const result = await Promise.all([\n            this._client.send('Page.enable'),\n            this._client.send('Page.getFrameTree'),\n        ]);\n        const { frameTree } = result[1];\n        this._handleFrameTree(frameTree);\n        await Promise.all([\n            this._client.send('Page.setLifecycleEventsEnabled', { enabled: true }),\n            this._client\n                .send('Runtime.enable')\n                .then(() => this._ensureIsolatedWorld(UTILITY_WORLD_NAME)),\n            this._networkManager.initialize(),\n        ]);\n    }\n    networkManager() {\n        return this._networkManager;\n    }\n    async navigateFrame(frame, url, options = {}) {\n        assertNoLegacyNavigationOptions(options);\n        const { referer = this._networkManager.extraHTTPHeaders()['referer'], waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;\n        const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this, frame, waitUntil, timeout);\n        let ensureNewDocumentNavigation = false;\n        let error = await Promise.race([\n            navigate(this._client, url, referer, frame._id),\n            watcher.timeoutOrTerminationPromise(),\n        ]);\n        if (!error) {\n            error = await Promise.race([\n                watcher.timeoutOrTerminationPromise(),\n                ensureNewDocumentNavigation\n                    ? watcher.newDocumentNavigationPromise()\n                    : watcher.sameDocumentNavigationPromise(),\n            ]);\n        }\n        watcher.dispose();\n        if (error)\n            throw error;\n        return watcher.navigationResponse();\n        async function navigate(client, url, referrer, frameId) {\n            try {\n                const response = await client.send('Page.navigate', {\n                    url,\n                    referrer,\n                    frameId,\n                });\n                ensureNewDocumentNavigation = !!response.loaderId;\n                return response.errorText\n                    ? new Error(`${response.errorText} at ${url}`)\n                    : null;\n            }\n            catch (error) {\n                return error;\n            }\n        }\n    }\n    async waitForFrameNavigation(frame, options = {}) {\n        assertNoLegacyNavigationOptions(options);\n        const { waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;\n        const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this, frame, waitUntil, timeout);\n        const error = await Promise.race([\n            watcher.timeoutOrTerminationPromise(),\n            watcher.sameDocumentNavigationPromise(),\n            watcher.newDocumentNavigationPromise(),\n        ]);\n        watcher.dispose();\n        if (error)\n            throw error;\n        return watcher.navigationResponse();\n    }\n    _onLifecycleEvent(event) {\n        const frame = this._frames.get(event.frameId);\n        if (!frame)\n            return;\n        frame._onLifecycleEvent(event.loaderId, event.name);\n        this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);\n    }\n    _onFrameStoppedLoading(frameId) {\n        const frame = this._frames.get(frameId);\n        if (!frame)\n            return;\n        frame._onLoadingStopped();\n        this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);\n    }\n    _handleFrameTree(frameTree) {\n        if (frameTree.frame.parentId)\n            this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId);\n        this._onFrameNavigated(frameTree.frame);\n        if (!frameTree.childFrames)\n            return;\n        for (const child of frameTree.childFrames)\n            this._handleFrameTree(child);\n    }\n    page() {\n        return this._page;\n    }\n    mainFrame() {\n        return this._mainFrame;\n    }\n    frames() {\n        return Array.from(this._frames.values());\n    }\n    frame(frameId) {\n        return this._frames.get(frameId) || null;\n    }\n    _onFrameAttached(frameId, parentFrameId) {\n        if (this._frames.has(frameId))\n            return;\n        assert_js_1.assert(parentFrameId);\n        const parentFrame = this._frames.get(parentFrameId);\n        const frame = new Frame(this, parentFrame, frameId);\n        this._frames.set(frame._id, frame);\n        this.emit(exports.FrameManagerEmittedEvents.FrameAttached, frame);\n    }\n    _onFrameNavigated(framePayload) {\n        const isMainFrame = !framePayload.parentId;\n        let frame = isMainFrame\n            ? this._mainFrame\n            : this._frames.get(framePayload.id);\n        assert_js_1.assert(isMainFrame || frame, 'We either navigate top level or have old version of the navigated frame');\n        // Detach all child frames first.\n        if (frame) {\n            for (const child of frame.childFrames())\n                this._removeFramesRecursively(child);\n        }\n        // Update or create main frame.\n        if (isMainFrame) {\n            if (frame) {\n                // Update frame id to retain frame identity on cross-process navigation.\n                this._frames.delete(frame._id);\n                frame._id = framePayload.id;\n            }\n            else {\n                // Initial main frame navigation.\n                frame = new Frame(this, null, framePayload.id);\n            }\n            this._frames.set(framePayload.id, frame);\n            this._mainFrame = frame;\n        }\n        // Update frame payload.\n        frame._navigated(framePayload);\n        this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);\n    }\n    async _ensureIsolatedWorld(name) {\n        if (this._isolatedWorlds.has(name))\n            return;\n        this._isolatedWorlds.add(name);\n        await this._client.send('Page.addScriptToEvaluateOnNewDocument', {\n            source: `//# sourceURL=${ExecutionContext_js_1.EVALUATION_SCRIPT_URL}`,\n            worldName: name,\n        }),\n            await Promise.all(this.frames().map((frame) => this._client\n                .send('Page.createIsolatedWorld', {\n                frameId: frame._id,\n                grantUniveralAccess: true,\n                worldName: name,\n            })\n                .catch(helper_js_1.debugError))); // frames might be removed before we send this\n    }\n    _onFrameNavigatedWithinDocument(frameId, url) {\n        const frame = this._frames.get(frameId);\n        if (!frame)\n            return;\n        frame._navigatedWithinDocument(url);\n        this.emit(exports.FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);\n        this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);\n    }\n    _onFrameDetached(frameId) {\n        const frame = this._frames.get(frameId);\n        if (frame)\n            this._removeFramesRecursively(frame);\n    }\n    _onExecutionContextCreated(contextPayload) {\n        const auxData = contextPayload.auxData;\n        const frameId = auxData ? auxData.frameId : null;\n        const frame = this._frames.get(frameId) || null;\n        let world = null;\n        if (frame) {\n            if (contextPayload.auxData && !!contextPayload.auxData['isDefault']) {\n                world = frame._mainWorld;\n            }\n            else if (contextPayload.name === UTILITY_WORLD_NAME &&\n                !frame._secondaryWorld._hasContext()) {\n                // In case of multiple sessions to the same target, there's a race between\n                // connections so we might end up creating multiple isolated worlds.\n                // We can use either.\n                world = frame._secondaryWorld;\n            }\n        }\n        if (contextPayload.auxData && contextPayload.auxData['type'] === 'isolated')\n            this._isolatedWorlds.add(contextPayload.name);\n        const context = new ExecutionContext_js_1.ExecutionContext(this._client, contextPayload, world);\n        if (world)\n            world._setContext(context);\n        this._contextIdToContext.set(contextPayload.id, context);\n    }\n    _onExecutionContextDestroyed(executionContextId) {\n        const context = this._contextIdToContext.get(executionContextId);\n        if (!context)\n            return;\n        this._contextIdToContext.delete(executionContextId);\n        if (context._world)\n            context._world._setContext(null);\n    }\n    _onExecutionContextsCleared() {\n        for (const context of this._contextIdToContext.values()) {\n            if (context._world)\n                context._world._setContext(null);\n        }\n        this._contextIdToContext.clear();\n    }\n    executionContextById(contextId) {\n        const context = this._contextIdToContext.get(contextId);\n        assert_js_1.assert(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n        return context;\n    }\n    _removeFramesRecursively(frame) {\n        for (const child of frame.childFrames())\n            this._removeFramesRecursively(child);\n        frame._detach();\n        this._frames.delete(frame._id);\n        this.emit(exports.FrameManagerEmittedEvents.FrameDetached, frame);\n    }\n}\nexports.FrameManager = FrameManager;\n/**\n * At every point of time, page exposes its current frame tree via the\n * {@link Page.mainFrame | page.mainFrame} and\n * {@link Frame.childFrames | frame.childFrames} methods.\n *\n * @remarks\n *\n * `Frame` object lifecycles are controlled by three events that are all\n * dispatched on the page object:\n *\n * - {@link PageEmittedEvents.FrameAttached}\n *\n * - {@link PageEmittedEvents.FrameNavigated}\n *\n * - {@link PageEmittedEvents.FrameDetached}\n *\n * @Example\n * An example of dumping frame tree:\n *\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://www.google.com/chrome/browser/canary.html');\n *   dumpFrameTree(page.mainFrame(), '');\n *   await browser.close();\n *\n *   function dumpFrameTree(frame, indent) {\n *     console.log(indent + frame.url());\n *     for (const child of frame.childFrames()) {\n *     dumpFrameTree(child, indent + '  ');\n *     }\n *   }\n * })();\n * ```\n *\n * @Example\n * An example of getting text from an iframe element:\n *\n * ```js\n * const frame = page.frames().find(frame => frame.name() === 'myframe');\n * const text = await frame.$eval('.selector', element => element.textContent);\n * console.log(text);\n * ```\n *\n * @public\n */\nclass Frame {\n    /**\n     * @internal\n     */\n    constructor(frameManager, parentFrame, frameId) {\n        this._url = '';\n        this._detached = false;\n        /**\n         * @internal\n         */\n        this._loaderId = '';\n        /**\n         * @internal\n         */\n        this._lifecycleEvents = new Set();\n        this._frameManager = frameManager;\n        this._parentFrame = parentFrame;\n        this._url = '';\n        this._id = frameId;\n        this._detached = false;\n        this._loaderId = '';\n        this._mainWorld = new DOMWorld_js_1.DOMWorld(frameManager, this, frameManager._timeoutSettings);\n        this._secondaryWorld = new DOMWorld_js_1.DOMWorld(frameManager, this, frameManager._timeoutSettings);\n        this._childFrames = new Set();\n        if (this._parentFrame)\n            this._parentFrame._childFrames.add(this);\n    }\n    /**\n     * @remarks\n     *\n     * `frame.goto` will throw an error if:\n     * - there's an SSL error (e.g. in case of self-signed certificates).\n     *\n     * - target URL is invalid.\n     *\n     * - the `timeout` is exceeded during navigation.\n     *\n     * - the remote server does not respond or is unreachable.\n     *\n     * - the main resource failed to load.\n     *\n     * `frame.goto` will not throw an error when any valid HTTP status code is\n     * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n     * Server Error\".  The status code for such responses can be retrieved by\n     * calling {@link HTTPResponse.status}.\n     *\n     * NOTE: `frame.goto` either throws an error or returns a main resource\n     * response. The only exceptions are navigation to `about:blank` or\n     * navigation to the same URL with a different hash, which would succeed and\n     * return `null`.\n     *\n     * NOTE: Headless mode doesn't support navigation to a PDF document. See\n     * the {@link https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n     * issue}.\n     *\n     * @param url - the URL to navigate the frame to. This should include the\n     * scheme, e.g. `https://`.\n     * @param options - navigation options. `waitUntil` is useful to define when\n     * the navigation should be considered successful - see the docs for\n     * {@link PuppeteerLifeCycleEvent} for more details.\n     *\n     * @returns A promise which resolves to the main resource response. In case of\n     * multiple redirects, the navigation will resolve with the response of the\n     * last redirect.\n     */\n    async goto(url, options = {}) {\n        return await this._frameManager.navigateFrame(this, url, options);\n    }\n    /**\n     * @remarks\n     *\n     * This resolves when the frame navigates to a new URL. It is useful for when\n     * you run code which will indirectly cause the frame to navigate. Consider\n     * this example:\n     *\n     * ```js\n     * const [response] = await Promise.all([\n     *   // The navigation promise resolves after navigation has finished\n     *   frame.waitForNavigation(),\n     *   // Clicking the link will indirectly cause a navigation\n     *   frame.click('a.my-link'),\n     * ]);\n     * ```\n     *\n     * Usage of the {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API} to change the URL is considered a navigation.\n     *\n     * @param options - options to configure when the navigation is consided finished.\n     * @returns a promise that resolves when the frame navigates to a new URL.\n     */\n    async waitForNavigation(options = {}) {\n        return await this._frameManager.waitForFrameNavigation(this, options);\n    }\n    /**\n     * @returns a promise that resolves to the frame's default execution context.\n     */\n    executionContext() {\n        return this._mainWorld.executionContext();\n    }\n    /**\n     * @remarks\n     *\n     * The only difference between {@link Frame.evaluate} and\n     * `frame.evaluateHandle` is that `evaluateHandle` will return the value\n     * wrapped in an in-page object.\n     *\n     * This method behaves identically to {@link Page.evaluateHandle} except it's\n     * run within the context of the `frame`, rather than the entire page.\n     *\n     * @param pageFunction - a function that is run within the frame\n     * @param args - arguments to be passed to the pageFunction\n     */\n    async evaluateHandle(pageFunction, ...args) {\n        return this._mainWorld.evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * @remarks\n     *\n     * This method behaves identically to {@link Page.evaluate} except it's run\n     * within the context of the `frame`, rather than the entire page.\n     *\n     * @param pageFunction - a function that is run within the frame\n     * @param args - arguments to be passed to the pageFunction\n     */\n    async evaluate(pageFunction, ...args) {\n        return this._mainWorld.evaluate(pageFunction, ...args);\n    }\n    /**\n     * This method queries the frame for the given selector.\n     *\n     * @param selector - a selector to query for.\n     * @returns A promise which resolves to an `ElementHandle` pointing at the\n     * element, or `null` if it was not found.\n     */\n    async $(selector) {\n        return this._mainWorld.$(selector);\n    }\n    /**\n     * This method evaluates the given XPath expression and returns the results.\n     *\n     * @param expression - the XPath expression to evaluate.\n     */\n    async $x(expression) {\n        return this._mainWorld.$x(expression);\n    }\n    /**\n     * @remarks\n     *\n     * This method runs `document.querySelector` within\n     * the frame and passes it as the first argument to `pageFunction`.\n     *\n     * If `pageFunction` returns a Promise, then `frame.$eval` would wait for\n     * the promise to resolve and return its value.\n     *\n     * @example\n     *\n     * ```js\n     * const searchValue = await frame.$eval('#search', el => el.value);\n     * ```\n     *\n     * @param selector - the selector to query for\n     * @param pageFunction - the function to be evaluated in the frame's context\n     * @param args - additional arguments to pass to `pageFuncton`\n     */\n    async $eval(selector, pageFunction, ...args) {\n        return this._mainWorld.$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * @remarks\n     *\n     * This method runs `Array.from(document.querySelectorAll(selector))` within\n     * the frame and passes it as the first argument to `pageFunction`.\n     *\n     * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for\n     * the promise to resolve and return its value.\n     *\n     * @example\n     *\n     * ```js\n     * const divsCounts = await frame.$$eval('div', divs => divs.length);\n     * ```\n     *\n     * @param selector - the selector to query for\n     * @param pageFunction - the function to be evaluated in the frame's context\n     * @param args - additional arguments to pass to `pageFuncton`\n     */\n    async $$eval(selector, pageFunction, ...args) {\n        return this._mainWorld.$$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * This runs `document.querySelectorAll` in the frame and returns the result.\n     *\n     * @param selector - a selector to search for\n     * @returns An array of element handles pointing to the found frame elements.\n     */\n    async $$(selector) {\n        return this._mainWorld.$$(selector);\n    }\n    /**\n     * @returns the full HTML contents of the frame, including the doctype.\n     */\n    async content() {\n        return this._secondaryWorld.content();\n    }\n    /**\n     * Set the content of the frame.\n     *\n     * @param html - HTML markup to assign to the page.\n     * @param options - options to configure how long before timing out and at\n     * what point to consider the content setting successful.\n     */\n    async setContent(html, options = {}) {\n        return this._secondaryWorld.setContent(html, options);\n    }\n    /**\n     * @remarks\n     *\n     * If the name is empty, it returns the `id` attribute instead.\n     *\n     * Note: This value is calculated once when the frame is created, and will not\n     * update if the attribute is changed later.\n     *\n     * @returns the frame's `name` attribute as specified in the tag.\n     */\n    name() {\n        return this._name || '';\n    }\n    /**\n     * @returns the frame's URL.\n     */\n    url() {\n        return this._url;\n    }\n    /**\n     * @returns the parent `Frame`, if any. Detached and main frames return `null`.\n     */\n    parentFrame() {\n        return this._parentFrame;\n    }\n    /**\n     * @returns an array of child frames.\n     */\n    childFrames() {\n        return Array.from(this._childFrames);\n    }\n    /**\n     * @returns `true` if the frame has been detached, or `false` otherwise.\n     */\n    isDetached() {\n        return this._detached;\n    }\n    /**\n     * Adds a `<script>` tag into the page with the desired url or content.\n     *\n     * @param options - configure the script to add to the page.\n     *\n     * @returns a promise that resolves to the added tag when the script's\n     * `onload` event fires or when the script content was injected into the\n     * frame.\n     */\n    async addScriptTag(options) {\n        return this._mainWorld.addScriptTag(options);\n    }\n    /**\n     * Adds a `<link rel=\"stylesheet\">` tag into the page with the desired url or\n     * a `<style type=\"text/css\">` tag with the content.\n     *\n     * @param options - configure the CSS to add to the page.\n     *\n     * @returns a promise that resolves to the added tag when the stylesheets's\n     * `onload` event fires or when the CSS content was injected into the\n     * frame.\n     */\n    async addStyleTag(options) {\n        return this._mainWorld.addStyleTag(options);\n    }\n    /**\n     *\n     * This method clicks the first element found that matches `selector`.\n     *\n     * @remarks\n     *\n     * This method scrolls the element into view if needed, and then uses\n     * {@link Page.mouse} to click in the center of the element. If there's no\n     * element matching `selector`, the method throws an error.\n     *\n     * Bear in mind that if `click()` triggers a navigation event and there's a\n     * separate `page.waitForNavigation()` promise to be resolved, you may end up\n     * with a race condition that yields unexpected results. The correct pattern\n     * for click and wait for navigation is the following:\n     *\n     * ```javascript\n     * const [response] = await Promise.all([\n     *   page.waitForNavigation(waitOptions),\n     *   frame.click(selector, clickOptions),\n     * ]);\n     * ```\n     * @param selector - the selector to search for to click. If there are\n     * multiple elements, the first will be clicked.\n     */\n    async click(selector, options = {}) {\n        return this._secondaryWorld.click(selector, options);\n    }\n    /**\n     * This method fetches an element with `selector` and focuses it.\n     *\n     * @remarks\n     * If there's no element matching `selector`, the method throws an error.\n     *\n     * @param selector - the selector for the element to focus. If there are\n     * multiple elements, the first will be focused.\n     */\n    async focus(selector) {\n        return this._secondaryWorld.focus(selector);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page.mouse} to hover over the center of the\n     * element.\n     *\n     * @remarks\n     * If there's no element matching `selector`, the method throws an\n     *\n     * @param selector - the selector for the element to hover. If there are\n     * multiple elements, the first will be hovered.\n     */\n    async hover(selector) {\n        return this._secondaryWorld.hover(selector);\n    }\n    /**\n     * Triggers a `change` and `input` event once all the provided options have\n     * been selected.\n     *\n     * @remarks\n     *\n     * If there's no `<select>` element matching `selector`, the\n     * method throws an error.\n     *\n     * @example\n     * ```js\n     * frame.select('select#colors', 'blue'); // single selection\n     * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n     * ```\n     *\n     * @param selector - a selector to query the frame for\n     * @param values - an array of values to select. If the `<select>` has the\n     * `multiple` attribute, all values are considered, otherwise only the first\n     * one is taken into account.\n     * @returns the list of values that were successfully selected.\n     */\n    select(selector, ...values) {\n        return this._secondaryWorld.select(selector, ...values);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page.touchscreen} to tap in the center of the\n     * element.\n     *\n     * @remarks\n     *\n     * If there's no element matching `selector`, the method throws an error.\n     *\n     * @param selector - the selector to tap.\n     * @returns a promise that resolves when the element has been tapped.\n     */\n    async tap(selector) {\n        return this._secondaryWorld.tap(selector);\n    }\n    /**\n     * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character\n     * in the text.\n     *\n     * @remarks\n     * To press a special key, like `Control` or `ArrowDown`, use\n     * {@link Keyboard.press}.\n     *\n     * @example\n     * ```js\n     * await frame.type('#mytextarea', 'Hello'); // Types instantly\n     * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user\n     * ```\n     *\n     * @param selector - the selector for the element to type into. If there are\n     * multiple the first will be used.\n     * @param text - text to type into the element\n     * @param options - takes one option, `delay`, which sets the time to wait\n     * between key presses in milliseconds. Defaults to `0`.\n     *\n     * @returns a promise that resolves when the typing is complete.\n     */\n    async type(selector, text, options) {\n        return this._mainWorld.type(selector, text, options);\n    }\n    /**\n     * @remarks\n     *\n     * This method behaves differently depending on the first parameter. If it's a\n     * `string`, it will be treated as a `selector` or `xpath` (if the string\n     * starts with `//`). This method then is a shortcut for\n     * {@link Frame.waitForSelector} or {@link Frame.waitForXPath}.\n     *\n     * If the first argument is a function this method is a shortcut for\n     * {@link Frame.waitForFunction}.\n     *\n     * If the first argument is a `number`, it's treated as a timeout in\n     * milliseconds and the method returns a promise which resolves after the\n     * timeout.\n     *\n     * @param selectorOrFunctionOrTimeout - a selector, predicate or timeout to\n     * wait for.\n     * @param options - optional waiting parameters.\n     * @param args - arguments to pass to `pageFunction`.\n     *\n     * @deprecated Don't use this method directly. Instead use the more explicit\n     * methods available: {@link Frame.waitForSelector},\n     * {@link Frame.waitForXPath}, {@link Frame.waitForFunction} or\n     * {@link Frame.waitForTimeout}.\n     */\n    waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {\n        const xPathPattern = '//';\n        console.warn('waitFor is deprecated and will be removed in a future release. See https://github.com/puppeteer/puppeteer/issues/6214 for details and how to migrate your code.');\n        if (helper_js_1.helper.isString(selectorOrFunctionOrTimeout)) {\n            const string = selectorOrFunctionOrTimeout;\n            if (string.startsWith(xPathPattern))\n                return this.waitForXPath(string, options);\n            return this.waitForSelector(string, options);\n        }\n        if (helper_js_1.helper.isNumber(selectorOrFunctionOrTimeout))\n            return new Promise((fulfill) => setTimeout(fulfill, selectorOrFunctionOrTimeout));\n        if (typeof selectorOrFunctionOrTimeout === 'function')\n            return this.waitForFunction(selectorOrFunctionOrTimeout, options, ...args);\n        return Promise.reject(new Error('Unsupported target type: ' + typeof selectorOrFunctionOrTimeout));\n    }\n    /**\n     * Causes your script to wait for the given number of milliseconds.\n     *\n     * @remarks\n     * It's generally recommended to not wait for a number of seconds, but instead\n     * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n     * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n     *\n     * @example\n     *\n     * Wait for 1 second:\n     *\n     * ```\n     * await frame.waitForTimeout(1000);\n     * ```\n     *\n     * @param milliseconds - the number of milliseconds to wait.\n     */\n    waitForTimeout(milliseconds) {\n        return new Promise((resolve) => {\n            setTimeout(resolve, milliseconds);\n        });\n    }\n    /**\n     * @remarks\n     *\n     *\n     * Wait for the `selector` to appear in page. If at the moment of calling the\n     * method the `selector` already exists, the method will return immediately.\n     * If the selector doesn't appear after the `timeout` milliseconds of waiting,\n     * the function will throw.\n     *\n     * This method works across navigations.\n     *\n     * @example\n     * ```js\n     * const puppeteer = require('puppeteer');\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page.mainFrame()\n     *   .waitForSelector('img')\n     *   .then(() => console.log('First URL with image: ' + currentURL));\n     *\n     *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com']) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     * @param selector - the selector to wait for.\n     * @param options - options to define if the element should be visible and how\n     * long to wait before timing out.\n     * @returns a promise which resolves when an element matching the selector\n     * string is added to the DOM.\n     */\n    async waitForSelector(selector, options = {}) {\n        const handle = await this._secondaryWorld.waitForSelector(selector, options);\n        if (!handle)\n            return null;\n        const mainExecutionContext = await this._mainWorld.executionContext();\n        const result = await mainExecutionContext._adoptElementHandle(handle);\n        await handle.dispose();\n        return result;\n    }\n    /**\n     * @remarks\n     * Wait for the `xpath` to appear in page. If at the moment of calling the\n     * method the `xpath` already exists, the method will return immediately. If\n     * the xpath doesn't appear after the `timeout` milliseconds of waiting, the\n     * function will throw.\n     *\n     * For a code example, see the example for {@link Frame.waitForSelector}. That\n     * function behaves identically other than taking a CSS selector rather than\n     * an XPath.\n     *\n     * @param xpath - the XPath expression to wait for.\n     * @param options  - options to configure the visiblity of the element and how\n     * long to wait before timing out.\n     */\n    async waitForXPath(xpath, options = {}) {\n        const handle = await this._secondaryWorld.waitForXPath(xpath, options);\n        if (!handle)\n            return null;\n        const mainExecutionContext = await this._mainWorld.executionContext();\n        const result = await mainExecutionContext._adoptElementHandle(handle);\n        await handle.dispose();\n        return result;\n    }\n    /**\n     * @remarks\n     *\n     * @example\n     *\n     * The `waitForFunction` can be used to observe viewport size change:\n     * ```js\n     * const puppeteer = require('puppeteer');\n     *\n     * (async () => {\n     * .  const browser = await puppeteer.launch();\n     * .  const page = await browser.newPage();\n     * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');\n     * .  page.setViewport({width: 50, height: 50});\n     * .  await watchDog;\n     * .  await browser.close();\n     * })();\n     * ```\n     *\n     * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:\n     *\n     * ```js\n     * const selector = '.foo';\n     * await frame.waitForFunction(\n     *   selector => !!document.querySelector(selector),\n     *   {}, // empty options object\n     *   selector\n     *);\n     * ```\n     *\n     * @param pageFunction - the function to evaluate in the frame context.\n     * @param options - options to configure the polling method and timeout.\n     * @param args - arguments to pass to the `pageFunction`.\n     * @returns the promise which resolve when the `pageFunction` returns a truthy value.\n     */\n    waitForFunction(pageFunction, options = {}, ...args) {\n        return this._mainWorld.waitForFunction(pageFunction, options, ...args);\n    }\n    /**\n     * @returns the frame's title.\n     */\n    async title() {\n        return this._secondaryWorld.title();\n    }\n    /**\n     * @internal\n     */\n    _navigated(framePayload) {\n        this._name = framePayload.name;\n        this._url = `${framePayload.url}${framePayload.urlFragment || ''}`;\n    }\n    /**\n     * @internal\n     */\n    _navigatedWithinDocument(url) {\n        this._url = url;\n    }\n    /**\n     * @internal\n     */\n    _onLifecycleEvent(loaderId, name) {\n        if (name === 'init') {\n            this._loaderId = loaderId;\n            this._lifecycleEvents.clear();\n        }\n        this._lifecycleEvents.add(name);\n    }\n    /**\n     * @internal\n     */\n    _onLoadingStopped() {\n        this._lifecycleEvents.add('DOMContentLoaded');\n        this._lifecycleEvents.add('load');\n    }\n    /**\n     * @internal\n     */\n    _detach() {\n        this._detached = true;\n        this._mainWorld._detach();\n        this._secondaryWorld._detach();\n        if (this._parentFrame)\n            this._parentFrame._childFrames.delete(this);\n        this._parentFrame = null;\n    }\n}\nexports.Frame = Frame;\nfunction assertNoLegacyNavigationOptions(options) {\n    assert_js_1.assert(options['networkIdleTimeout'] === undefined, 'ERROR: networkIdleTimeout option is no longer supported.');\n    assert_js_1.assert(options['networkIdleInflight'] === undefined, 'ERROR: networkIdleInflight option is no longer supported.');\n    assert_js_1.assert(options.waitUntil !== 'networkidle', 'ERROR: \"networkidle\" option is no longer supported. Use \"networkidle2\" instead');\n}\n"]},"metadata":{},"sourceType":"script"}