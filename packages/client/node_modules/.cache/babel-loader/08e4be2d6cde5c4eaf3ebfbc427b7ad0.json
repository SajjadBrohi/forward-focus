{"ast":null,"code":"var fs = require(\"fs\");\n\nvar zlib = require(\"zlib\");\n\nvar fd_slicer = require(\"fd-slicer\");\n\nvar crc32 = require(\"buffer-crc32\");\n\nvar util = require(\"util\");\n\nvar EventEmitter = require(\"events\").EventEmitter;\n\nvar Transform = require(\"stream\").Transform;\n\nvar PassThrough = require(\"stream\").PassThrough;\n\nvar Writable = require(\"stream\").Writable;\n\nexports.open = open;\nexports.fromFd = fromFd;\nexports.fromBuffer = fromBuffer;\nexports.fromRandomAccessReader = fromRandomAccessReader;\nexports.dosDateTimeToDate = dosDateTimeToDate;\nexports.validateFileName = validateFileName;\nexports.ZipFile = ZipFile;\nexports.Entry = Entry;\nexports.RandomAccessReader = RandomAccessReader;\n\nfunction open(path, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.open(path, \"r\", function (err, fd) {\n    if (err) return callback(err);\n    fromFd(fd, options, function (err, zipfile) {\n      if (err) fs.close(fd, defaultCallback);\n      callback(err, zipfile);\n    });\n  });\n}\n\nfunction fromFd(fd, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.fstat(fd, function (err, stats) {\n    if (err) return callback(err);\n    var reader = fd_slicer.createFromFd(fd, {\n      autoClose: true\n    });\n    fromRandomAccessReader(reader, stats.size, options, callback);\n  });\n}\n\nfunction fromBuffer(buffer, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n\n  if (options == null) options = {};\n  options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false; // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87\n\n  var reader = fd_slicer.createFromBuffer(buffer, {\n    maxChunkSize: 0x10000\n  });\n  fromRandomAccessReader(reader, buffer.length, options, callback);\n}\n\nfunction fromRandomAccessReader(reader, totalSize, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  var decodeStrings = !!options.decodeStrings;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  if (typeof totalSize !== \"number\") throw new Error(\"expected totalSize parameter to be a number\");\n\n  if (totalSize > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.\");\n  } // the matching unref() call is in zipfile.close()\n\n\n  reader.ref(); // eocdr means End of Central Directory Record.\n  // search backwards for the eocdr signature.\n  // the last field of the eocdr is a variable-length comment.\n  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.\n  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.\n  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.\n\n  var eocdrWithoutCommentSize = 22;\n  var maxCommentSize = 0xffff; // 2-byte size\n\n  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);\n  var buffer = newBuffer(bufferSize);\n  var bufferReadStart = totalSize - buffer.length;\n  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function (err) {\n    if (err) return callback(err);\n\n    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {\n      if (buffer.readUInt32LE(i) !== 0x06054b50) continue; // found eocdr\n\n      var eocdrBuffer = buffer.slice(i); // 0 - End of central directory signature = 0x06054b50\n      // 4 - Number of this disk\n\n      var diskNumber = eocdrBuffer.readUInt16LE(4);\n\n      if (diskNumber !== 0) {\n        return callback(new Error(\"multi-disk zip files are not supported: found disk number: \" + diskNumber));\n      } // 6 - Disk where central directory starts\n      // 8 - Number of central directory records on this disk\n      // 10 - Total number of central directory records\n\n\n      var entryCount = eocdrBuffer.readUInt16LE(10); // 12 - Size of central directory (bytes)\n      // 16 - Offset of start of central directory, relative to start of archive\n\n      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16); // 20 - Comment length\n\n      var commentLength = eocdrBuffer.readUInt16LE(20);\n      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;\n\n      if (commentLength !== expectedCommentLength) {\n        return callback(new Error(\"invalid comment length. expected: \" + expectedCommentLength + \". found: \" + commentLength));\n      } // 22 - Comment\n      // the encoding is always cp437.\n\n\n      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);\n\n      if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {\n        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n      } // ZIP64 format\n      // ZIP64 Zip64 end of central directory locator\n\n\n      var zip64EocdlBuffer = newBuffer(20);\n      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;\n      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function (err) {\n        if (err) return callback(err); // 0 - zip64 end of central dir locator signature = 0x07064b50\n\n        if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {\n          return callback(new Error(\"invalid zip64 end of central directory locator signature\"));\n        } // 4 - number of the disk with the start of the zip64 end of central directory\n        // 8 - relative offset of the zip64 end of central directory record\n\n\n        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8); // 16 - total number of disks\n        // ZIP64 end of central directory record\n\n        var zip64EocdrBuffer = newBuffer(56);\n        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function (err) {\n          if (err) return callback(err); // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n\n          if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {\n            return callback(new Error(\"invalid zip64 end of central directory record signature\"));\n          } // 4 - size of zip64 end of central directory record                8 bytes\n          // 12 - version made by                                             2 bytes\n          // 14 - version needed to extract                                   2 bytes\n          // 16 - number of this disk                                         4 bytes\n          // 20 - number of the disk with the start of the central directory  4 bytes\n          // 24 - total number of entries in the central directory on this disk         8 bytes\n          // 32 - total number of entries in the central directory            8 bytes\n\n\n          entryCount = readUInt64LE(zip64EocdrBuffer, 32); // 40 - size of the central directory                               8 bytes\n          // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n\n          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48); // 56 - zip64 extensible data sector                                (variable size)\n\n          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n        });\n      });\n      return;\n    }\n\n    callback(new Error(\"end of central directory record signature not found\"));\n  });\n}\n\nutil.inherits(ZipFile, EventEmitter);\n\nfunction ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {\n  var self = this;\n  EventEmitter.call(self);\n  self.reader = reader; // forward close events\n\n  self.reader.on(\"error\", function (err) {\n    // error closing the fd\n    emitError(self, err);\n  });\n  self.reader.once(\"close\", function () {\n    self.emit(\"close\");\n  });\n  self.readEntryCursor = centralDirectoryOffset;\n  self.fileSize = fileSize;\n  self.entryCount = entryCount;\n  self.comment = comment;\n  self.entriesRead = 0;\n  self.autoClose = !!autoClose;\n  self.lazyEntries = !!lazyEntries;\n  self.decodeStrings = !!decodeStrings;\n  self.validateEntrySizes = !!validateEntrySizes;\n  self.strictFileNames = !!strictFileNames;\n  self.isOpen = true;\n  self.emittedError = false;\n  if (!self.lazyEntries) self._readEntry();\n}\n\nZipFile.prototype.close = function () {\n  if (!this.isOpen) return;\n  this.isOpen = false;\n  this.reader.unref();\n};\n\nfunction emitErrorAndAutoClose(self, err) {\n  if (self.autoClose) self.close();\n  emitError(self, err);\n}\n\nfunction emitError(self, err) {\n  if (self.emittedError) return;\n  self.emittedError = true;\n  self.emit(\"error\", err);\n}\n\nZipFile.prototype.readEntry = function () {\n  if (!this.lazyEntries) throw new Error(\"readEntry() called without lazyEntries:true\");\n\n  this._readEntry();\n};\n\nZipFile.prototype._readEntry = function () {\n  var self = this;\n\n  if (self.entryCount === self.entriesRead) {\n    // done with metadata\n    setImmediate(function () {\n      if (self.autoClose) self.close();\n      if (self.emittedError) return;\n      self.emit(\"end\");\n    });\n    return;\n  }\n\n  if (self.emittedError) return;\n  var buffer = newBuffer(46);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function (err) {\n    if (err) return emitErrorAndAutoClose(self, err);\n    if (self.emittedError) return;\n    var entry = new Entry(); // 0 - Central directory file header signature\n\n    var signature = buffer.readUInt32LE(0);\n    if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error(\"invalid central directory file header signature: 0x\" + signature.toString(16))); // 4 - Version made by\n\n    entry.versionMadeBy = buffer.readUInt16LE(4); // 6 - Version needed to extract (minimum)\n\n    entry.versionNeededToExtract = buffer.readUInt16LE(6); // 8 - General purpose bit flag\n\n    entry.generalPurposeBitFlag = buffer.readUInt16LE(8); // 10 - Compression method\n\n    entry.compressionMethod = buffer.readUInt16LE(10); // 12 - File last modification time\n\n    entry.lastModFileTime = buffer.readUInt16LE(12); // 14 - File last modification date\n\n    entry.lastModFileDate = buffer.readUInt16LE(14); // 16 - CRC-32\n\n    entry.crc32 = buffer.readUInt32LE(16); // 20 - Compressed size\n\n    entry.compressedSize = buffer.readUInt32LE(20); // 24 - Uncompressed size\n\n    entry.uncompressedSize = buffer.readUInt32LE(24); // 28 - File name length (n)\n\n    entry.fileNameLength = buffer.readUInt16LE(28); // 30 - Extra field length (m)\n\n    entry.extraFieldLength = buffer.readUInt16LE(30); // 32 - File comment length (k)\n\n    entry.fileCommentLength = buffer.readUInt16LE(32); // 34 - Disk number where file starts\n    // 36 - Internal file attributes\n\n    entry.internalFileAttributes = buffer.readUInt16LE(36); // 38 - External file attributes\n\n    entry.externalFileAttributes = buffer.readUInt32LE(38); // 42 - Relative offset of local file header\n\n    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);\n    if (entry.generalPurposeBitFlag & 0x40) return emitErrorAndAutoClose(self, new Error(\"strong encryption is not supported\"));\n    self.readEntryCursor += 46;\n    buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);\n    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function (err) {\n      if (err) return emitErrorAndAutoClose(self, err);\n      if (self.emittedError) return; // 46 - File name\n\n      var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;\n      entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength); // 46+n - Extra field\n\n      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;\n      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);\n      entry.extraFields = [];\n      var i = 0;\n\n      while (i < extraFieldBuffer.length - 3) {\n        var headerId = extraFieldBuffer.readUInt16LE(i + 0);\n        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);\n        var dataStart = i + 4;\n        var dataEnd = dataStart + dataSize;\n        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error(\"extra field length exceeds extra field buffer size\"));\n        var dataBuffer = newBuffer(dataSize);\n        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);\n        entry.extraFields.push({\n          id: headerId,\n          data: dataBuffer\n        });\n        i = dataEnd;\n      } // 46+n+m - File comment\n\n\n      entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength); // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47\n\n      entry.comment = entry.fileComment;\n      self.readEntryCursor += buffer.length;\n      self.entriesRead += 1;\n\n      if (entry.uncompressedSize === 0xffffffff || entry.compressedSize === 0xffffffff || entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        // ZIP64 format\n        // find the Zip64 Extended Information Extra Field\n        var zip64EiefBuffer = null;\n\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n\n          if (extraField.id === 0x0001) {\n            zip64EiefBuffer = extraField.data;\n            break;\n          }\n        }\n\n        if (zip64EiefBuffer == null) {\n          return emitErrorAndAutoClose(self, new Error(\"expected zip64 extended information extra field\"));\n        }\n\n        var index = 0; // 0 - Original Size          8 bytes\n\n        if (entry.uncompressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include uncompressed size\"));\n          }\n\n          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        } // 8 - Compressed Size        8 bytes\n\n\n        if (entry.compressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include compressed size\"));\n          }\n\n          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        } // 16 - Relative Header Offset 8 bytes\n\n\n        if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include relative header offset\"));\n          }\n\n          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        } // 24 - Disk Start Number      4 bytes\n\n      } // check for Info-ZIP Unicode Path Extra Field (0x7075)\n      // see https://github.com/thejoshwolfe/yauzl/issues/33\n\n\n      if (self.decodeStrings) {\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n\n          if (extraField.id === 0x7075) {\n            if (extraField.data.length < 6) {\n              // too short to be meaningful\n              continue;\n            } // Version       1 byte      version of this extra field, currently 1\n\n\n            if (extraField.data.readUInt8(0) !== 1) {\n              // > Changes may not be backward compatible so this extra\n              // > field should not be used if the version is not recognized.\n              continue;\n            } // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n\n\n            var oldNameCrc32 = extraField.data.readUInt32LE(1);\n\n            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {\n              // > If the CRC check fails, this UTF-8 Path Extra Field should be\n              // > ignored and the File Name field in the header should be used instead.\n              continue;\n            } // UnicodeName   Variable    UTF-8 version of the entry File Name\n\n\n            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);\n            break;\n          }\n        }\n      } // validate file size\n\n\n      if (self.validateEntrySizes && entry.compressionMethod === 0) {\n        var expectedCompressedSize = entry.uncompressedSize;\n\n        if (entry.isEncrypted()) {\n          // traditional encryption prefixes the file data with a header\n          expectedCompressedSize += 12;\n        }\n\n        if (entry.compressedSize !== expectedCompressedSize) {\n          var msg = \"compressed/uncompressed size mismatch for stored file: \" + entry.compressedSize + \" != \" + entry.uncompressedSize;\n          return emitErrorAndAutoClose(self, new Error(msg));\n        }\n      }\n\n      if (self.decodeStrings) {\n        if (!self.strictFileNames) {\n          // allow backslash\n          entry.fileName = entry.fileName.replace(/\\\\/g, \"/\");\n        }\n\n        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);\n        if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));\n      }\n\n      self.emit(\"entry\", entry);\n      if (!self.lazyEntries) self._readEntry();\n    });\n  });\n};\n\nZipFile.prototype.openReadStream = function (entry, options, callback) {\n  var self = this; // parameter validation\n\n  var relativeStart = 0;\n  var relativeEnd = entry.compressedSize;\n\n  if (callback == null) {\n    callback = options;\n    options = {};\n  } else {\n    // validate options that the caller has no excuse to get wrong\n    if (options.decrypt != null) {\n      if (!entry.isEncrypted()) {\n        throw new Error(\"options.decrypt can only be specified for encrypted entries\");\n      }\n\n      if (options.decrypt !== false) throw new Error(\"invalid options.decrypt value: \" + options.decrypt);\n\n      if (entry.isCompressed()) {\n        if (options.decompress !== false) throw new Error(\"entry is encrypted and compressed, and options.decompress !== false\");\n      }\n    }\n\n    if (options.decompress != null) {\n      if (!entry.isCompressed()) {\n        throw new Error(\"options.decompress can only be specified for compressed entries\");\n      }\n\n      if (!(options.decompress === false || options.decompress === true)) {\n        throw new Error(\"invalid options.decompress value: \" + options.decompress);\n      }\n    }\n\n    if (options.start != null || options.end != null) {\n      if (entry.isCompressed() && options.decompress !== false) {\n        throw new Error(\"start/end range not allowed for compressed entry without options.decompress === false\");\n      }\n\n      if (entry.isEncrypted() && options.decrypt !== false) {\n        throw new Error(\"start/end range not allowed for encrypted entry without options.decrypt === false\");\n      }\n    }\n\n    if (options.start != null) {\n      relativeStart = options.start;\n      if (relativeStart < 0) throw new Error(\"options.start < 0\");\n      if (relativeStart > entry.compressedSize) throw new Error(\"options.start > entry.compressedSize\");\n    }\n\n    if (options.end != null) {\n      relativeEnd = options.end;\n      if (relativeEnd < 0) throw new Error(\"options.end < 0\");\n      if (relativeEnd > entry.compressedSize) throw new Error(\"options.end > entry.compressedSize\");\n      if (relativeEnd < relativeStart) throw new Error(\"options.end < options.start\");\n    }\n  } // any further errors can either be caused by the zipfile,\n  // or were introduced in a minor version of yauzl,\n  // so should be passed to the client rather than thrown.\n\n\n  if (!self.isOpen) return callback(new Error(\"closed\"));\n\n  if (entry.isEncrypted()) {\n    if (options.decrypt !== false) return callback(new Error(\"entry is encrypted, and options.decrypt !== false\"));\n  } // make sure we don't lose the fd before we open the actual read stream\n\n\n  self.reader.ref();\n  var buffer = newBuffer(30);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function (err) {\n    try {\n      if (err) return callback(err); // 0 - Local file header signature = 0x04034b50\n\n      var signature = buffer.readUInt32LE(0);\n\n      if (signature !== 0x04034b50) {\n        return callback(new Error(\"invalid local file header signature: 0x\" + signature.toString(16)));\n      } // all this should be redundant\n      // 4 - Version needed to extract (minimum)\n      // 6 - General purpose bit flag\n      // 8 - Compression method\n      // 10 - File last modification time\n      // 12 - File last modification date\n      // 14 - CRC-32\n      // 18 - Compressed size\n      // 22 - Uncompressed size\n      // 26 - File name length (n)\n\n\n      var fileNameLength = buffer.readUInt16LE(26); // 28 - Extra field length (m)\n\n      var extraFieldLength = buffer.readUInt16LE(28); // 30 - File name\n      // 30+n - Extra field\n\n      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n      var decompress;\n\n      if (entry.compressionMethod === 0) {\n        // 0 - The file is stored (no compression)\n        decompress = false;\n      } else if (entry.compressionMethod === 8) {\n        // 8 - The file is Deflated\n        decompress = options.decompress != null ? options.decompress : true;\n      } else {\n        return callback(new Error(\"unsupported compression method: \" + entry.compressionMethod));\n      }\n\n      var fileDataStart = localFileHeaderEnd;\n      var fileDataEnd = fileDataStart + entry.compressedSize;\n\n      if (entry.compressedSize !== 0) {\n        // bounds check now, because the read streams will probably not complain loud enough.\n        // since we're dealing with an unsigned offset plus an unsigned size,\n        // we only have 1 thing to check for.\n        if (fileDataEnd > self.fileSize) {\n          return callback(new Error(\"file data overflows file bounds: \" + fileDataStart + \" + \" + entry.compressedSize + \" > \" + self.fileSize));\n        }\n      }\n\n      var readStream = self.reader.createReadStream({\n        start: fileDataStart + relativeStart,\n        end: fileDataStart + relativeEnd\n      });\n      var endpointStream = readStream;\n\n      if (decompress) {\n        var destroyed = false;\n        var inflateFilter = zlib.createInflateRaw();\n        readStream.on(\"error\", function (err) {\n          // setImmediate here because errors can be emitted during the first call to pipe()\n          setImmediate(function () {\n            if (!destroyed) inflateFilter.emit(\"error\", err);\n          });\n        });\n        readStream.pipe(inflateFilter);\n\n        if (self.validateEntrySizes) {\n          endpointStream = new AssertByteCountStream(entry.uncompressedSize);\n          inflateFilter.on(\"error\", function (err) {\n            // forward zlib errors to the client-visible stream\n            setImmediate(function () {\n              if (!destroyed) endpointStream.emit(\"error\", err);\n            });\n          });\n          inflateFilter.pipe(endpointStream);\n        } else {\n          // the zlib filter is the client-visible stream\n          endpointStream = inflateFilter;\n        } // this is part of yauzl's API, so implement this function on the client-visible stream\n\n\n        endpointStream.destroy = function () {\n          destroyed = true;\n          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);\n          readStream.unpipe(inflateFilter); // TODO: the inflateFilter may cause a memory leak. see Issue #27.\n\n          readStream.destroy();\n        };\n      }\n\n      callback(null, endpointStream);\n    } finally {\n      self.reader.unref();\n    }\n  });\n};\n\nfunction Entry() {}\n\nEntry.prototype.getLastModDate = function () {\n  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);\n};\n\nEntry.prototype.isEncrypted = function () {\n  return (this.generalPurposeBitFlag & 0x1) !== 0;\n};\n\nEntry.prototype.isCompressed = function () {\n  return this.compressionMethod === 8;\n};\n\nfunction dosDateTimeToDate(date, time) {\n  var day = date & 0x1f; // 1-31\n\n  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n\n  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  var millisecond = 0;\n  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n\n  var minute = time >> 5 & 0x3f; // 0-59\n\n  var hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nfunction validateFileName(fileName) {\n  if (fileName.indexOf(\"\\\\\") !== -1) {\n    return \"invalid characters in fileName: \" + fileName;\n  }\n\n  if (/^[a-zA-Z]:/.test(fileName) || /^\\//.test(fileName)) {\n    return \"absolute path: \" + fileName;\n  }\n\n  if (fileName.split(\"/\").indexOf(\"..\") !== -1) {\n    return \"invalid relative path: \" + fileName;\n  } // all good\n\n\n  return null;\n}\n\nfunction readAndAssertNoEof(reader, buffer, offset, length, position, callback) {\n  if (length === 0) {\n    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file\n    return setImmediate(function () {\n      callback(null, newBuffer(0));\n    });\n  }\n\n  reader.read(buffer, offset, length, position, function (err, bytesRead) {\n    if (err) return callback(err);\n\n    if (bytesRead < length) {\n      return callback(new Error(\"unexpected EOF\"));\n    }\n\n    callback();\n  });\n}\n\nutil.inherits(AssertByteCountStream, Transform);\n\nfunction AssertByteCountStream(byteCount) {\n  Transform.call(this);\n  this.actualByteCount = 0;\n  this.expectedByteCount = byteCount;\n}\n\nAssertByteCountStream.prototype._transform = function (chunk, encoding, cb) {\n  this.actualByteCount += chunk.length;\n\n  if (this.actualByteCount > this.expectedByteCount) {\n    var msg = \"too many bytes in the stream. expected \" + this.expectedByteCount + \". got at least \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n\n  cb(null, chunk);\n};\n\nAssertByteCountStream.prototype._flush = function (cb) {\n  if (this.actualByteCount < this.expectedByteCount) {\n    var msg = \"not enough bytes in the stream. expected \" + this.expectedByteCount + \". got only \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n\n  cb();\n};\n\nutil.inherits(RandomAccessReader, EventEmitter);\n\nfunction RandomAccessReader() {\n  EventEmitter.call(this);\n  this.refCount = 0;\n}\n\nRandomAccessReader.prototype.ref = function () {\n  this.refCount += 1;\n};\n\nRandomAccessReader.prototype.unref = function () {\n  var self = this;\n  self.refCount -= 1;\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n  self.close(onCloseDone);\n\n  function onCloseDone(err) {\n    if (err) return self.emit('error', err);\n    self.emit('close');\n  }\n};\n\nRandomAccessReader.prototype.createReadStream = function (options) {\n  var start = options.start;\n  var end = options.end;\n\n  if (start === end) {\n    var emptyStream = new PassThrough();\n    setImmediate(function () {\n      emptyStream.end();\n    });\n    return emptyStream;\n  }\n\n  var stream = this._readStreamForRange(start, end);\n\n  var destroyed = false;\n  var refUnrefFilter = new RefUnrefFilter(this);\n  stream.on(\"error\", function (err) {\n    setImmediate(function () {\n      if (!destroyed) refUnrefFilter.emit(\"error\", err);\n    });\n  });\n\n  refUnrefFilter.destroy = function () {\n    stream.unpipe(refUnrefFilter);\n    refUnrefFilter.unref();\n    stream.destroy();\n  };\n\n  var byteCounter = new AssertByteCountStream(end - start);\n  refUnrefFilter.on(\"error\", function (err) {\n    setImmediate(function () {\n      if (!destroyed) byteCounter.emit(\"error\", err);\n    });\n  });\n\n  byteCounter.destroy = function () {\n    destroyed = true;\n    refUnrefFilter.unpipe(byteCounter);\n    refUnrefFilter.destroy();\n  };\n\n  return stream.pipe(refUnrefFilter).pipe(byteCounter);\n};\n\nRandomAccessReader.prototype._readStreamForRange = function (start, end) {\n  throw new Error(\"not implemented\");\n};\n\nRandomAccessReader.prototype.read = function (buffer, offset, length, position, callback) {\n  var readStream = this.createReadStream({\n    start: position,\n    end: position + length\n  });\n  var writeStream = new Writable();\n  var written = 0;\n\n  writeStream._write = function (chunk, encoding, cb) {\n    chunk.copy(buffer, offset + written, 0, chunk.length);\n    written += chunk.length;\n    cb();\n  };\n\n  writeStream.on(\"finish\", callback);\n  readStream.on(\"error\", function (error) {\n    callback(error);\n  });\n  readStream.pipe(writeStream);\n};\n\nRandomAccessReader.prototype.close = function (callback) {\n  setImmediate(callback);\n};\n\nutil.inherits(RefUnrefFilter, PassThrough);\n\nfunction RefUnrefFilter(context) {\n  PassThrough.call(this);\n  this.context = context;\n  this.context.ref();\n  this.unreffedYet = false;\n}\n\nRefUnrefFilter.prototype._flush = function (cb) {\n  this.unref();\n  cb();\n};\n\nRefUnrefFilter.prototype.unref = function (cb) {\n  if (this.unreffedYet) return;\n  this.unreffedYet = true;\n  this.context.unref();\n};\n\nvar cp437 = '\\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';\n\nfunction decodeBuffer(buffer, start, end, isUtf8) {\n  if (isUtf8) {\n    return buffer.toString(\"utf8\", start, end);\n  } else {\n    var result = \"\";\n\n    for (var i = start; i < end; i++) {\n      result += cp437[buffer[i]];\n    }\n\n    return result;\n  }\n}\n\nfunction readUInt64LE(buffer, offset) {\n  // there is no native function for this, because we can't actually store 64-bit integers precisely.\n  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.\n  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.\n  var lower32 = buffer.readUInt32LE(offset);\n  var upper32 = buffer.readUInt32LE(offset + 4); // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.\n\n  return upper32 * 0x100000000 + lower32; // as long as we're bounds checking the result of this function against the total file size,\n  // we'll catch any overflow errors, because we already made sure the total file size was within reason.\n} // Node 10 deprecated new Buffer().\n\n\nvar newBuffer;\n\nif (typeof Buffer.allocUnsafe === \"function\") {\n  newBuffer = function (len) {\n    return Buffer.allocUnsafe(len);\n  };\n} else {\n  newBuffer = function (len) {\n    return new Buffer(len);\n  };\n}\n\nfunction defaultCallback(err) {\n  if (err) throw err;\n}","map":{"version":3,"sources":["C:/Users/Sajjad Brohi/JavaScript Projects/RESTful API/packages/client/node_modules/yauzl/index.js"],"names":["fs","require","zlib","fd_slicer","crc32","util","EventEmitter","Transform","PassThrough","Writable","exports","open","fromFd","fromBuffer","fromRandomAccessReader","dosDateTimeToDate","validateFileName","ZipFile","Entry","RandomAccessReader","path","options","callback","autoClose","lazyEntries","decodeStrings","validateEntrySizes","strictFileNames","defaultCallback","err","fd","zipfile","close","fstat","stats","reader","createFromFd","size","buffer","createFromBuffer","maxChunkSize","length","totalSize","Error","Number","MAX_SAFE_INTEGER","ref","eocdrWithoutCommentSize","maxCommentSize","bufferSize","Math","min","newBuffer","bufferReadStart","readAndAssertNoEof","i","readUInt32LE","eocdrBuffer","slice","diskNumber","readUInt16LE","entryCount","centralDirectoryOffset","commentLength","expectedCommentLength","comment","decodeBuffer","zip64EocdlBuffer","zip64EocdlOffset","zip64EocdrOffset","readUInt64LE","zip64EocdrBuffer","inherits","fileSize","self","call","on","emitError","once","emit","readEntryCursor","entriesRead","isOpen","emittedError","_readEntry","prototype","unref","emitErrorAndAutoClose","readEntry","setImmediate","entry","signature","toString","versionMadeBy","versionNeededToExtract","generalPurposeBitFlag","compressionMethod","lastModFileTime","lastModFileDate","compressedSize","uncompressedSize","fileNameLength","extraFieldLength","fileCommentLength","internalFileAttributes","externalFileAttributes","relativeOffsetOfLocalHeader","isUtf8","fileName","fileCommentStart","extraFieldBuffer","extraFields","headerId","dataSize","dataStart","dataEnd","dataBuffer","copy","push","id","data","fileComment","zip64EiefBuffer","extraField","index","readUInt8","oldNameCrc32","unsigned","expectedCompressedSize","isEncrypted","msg","replace","errorMessage","validateFileNameOptions","openReadStream","relativeStart","relativeEnd","decrypt","isCompressed","decompress","start","end","localFileHeaderEnd","fileDataStart","fileDataEnd","readStream","createReadStream","endpointStream","destroyed","inflateFilter","createInflateRaw","pipe","AssertByteCountStream","destroy","unpipe","getLastModDate","date","time","day","month","year","millisecond","second","minute","hour","Date","indexOf","test","split","offset","position","read","bytesRead","byteCount","actualByteCount","expectedByteCount","_transform","chunk","encoding","cb","_flush","refCount","onCloseDone","emptyStream","stream","_readStreamForRange","refUnrefFilter","RefUnrefFilter","byteCounter","writeStream","written","_write","error","context","unreffedYet","cp437","result","lower32","upper32","Buffer","allocUnsafe","len"],"mappings":"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","sourcesContent":["var fs = require(\"fs\");\nvar zlib = require(\"zlib\");\nvar fd_slicer = require(\"fd-slicer\");\nvar crc32 = require(\"buffer-crc32\");\nvar util = require(\"util\");\nvar EventEmitter = require(\"events\").EventEmitter;\nvar Transform = require(\"stream\").Transform;\nvar PassThrough = require(\"stream\").PassThrough;\nvar Writable = require(\"stream\").Writable;\n\nexports.open = open;\nexports.fromFd = fromFd;\nexports.fromBuffer = fromBuffer;\nexports.fromRandomAccessReader = fromRandomAccessReader;\nexports.dosDateTimeToDate = dosDateTimeToDate;\nexports.validateFileName = validateFileName;\nexports.ZipFile = ZipFile;\nexports.Entry = Entry;\nexports.RandomAccessReader = RandomAccessReader;\n\nfunction open(path, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.open(path, \"r\", function(err, fd) {\n    if (err) return callback(err);\n    fromFd(fd, options, function(err, zipfile) {\n      if (err) fs.close(fd, defaultCallback);\n      callback(err, zipfile);\n    });\n  });\n}\n\nfunction fromFd(fd, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  fs.fstat(fd, function(err, stats) {\n    if (err) return callback(err);\n    var reader = fd_slicer.createFromFd(fd, {autoClose: true});\n    fromRandomAccessReader(reader, stats.size, options, callback);\n  });\n}\n\nfunction fromBuffer(buffer, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87\n  var reader = fd_slicer.createFromBuffer(buffer, {maxChunkSize: 0x10000});\n  fromRandomAccessReader(reader, buffer.length, options, callback);\n}\n\nfunction fromRandomAccessReader(reader, totalSize, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (options.decodeStrings == null) options.decodeStrings = true;\n  var decodeStrings = !!options.decodeStrings;\n  if (options.validateEntrySizes == null) options.validateEntrySizes = true;\n  if (options.strictFileNames == null) options.strictFileNames = false;\n  if (callback == null) callback = defaultCallback;\n  if (typeof totalSize !== \"number\") throw new Error(\"expected totalSize parameter to be a number\");\n  if (totalSize > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.\");\n  }\n\n  // the matching unref() call is in zipfile.close()\n  reader.ref();\n\n  // eocdr means End of Central Directory Record.\n  // search backwards for the eocdr signature.\n  // the last field of the eocdr is a variable-length comment.\n  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.\n  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.\n  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.\n  var eocdrWithoutCommentSize = 22;\n  var maxCommentSize = 0xffff; // 2-byte size\n  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);\n  var buffer = newBuffer(bufferSize);\n  var bufferReadStart = totalSize - buffer.length;\n  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {\n    if (err) return callback(err);\n    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {\n      if (buffer.readUInt32LE(i) !== 0x06054b50) continue;\n      // found eocdr\n      var eocdrBuffer = buffer.slice(i);\n\n      // 0 - End of central directory signature = 0x06054b50\n      // 4 - Number of this disk\n      var diskNumber = eocdrBuffer.readUInt16LE(4);\n      if (diskNumber !== 0) {\n        return callback(new Error(\"multi-disk zip files are not supported: found disk number: \" + diskNumber));\n      }\n      // 6 - Disk where central directory starts\n      // 8 - Number of central directory records on this disk\n      // 10 - Total number of central directory records\n      var entryCount = eocdrBuffer.readUInt16LE(10);\n      // 12 - Size of central directory (bytes)\n      // 16 - Offset of start of central directory, relative to start of archive\n      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);\n      // 20 - Comment length\n      var commentLength = eocdrBuffer.readUInt16LE(20);\n      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;\n      if (commentLength !== expectedCommentLength) {\n        return callback(new Error(\"invalid comment length. expected: \" + expectedCommentLength + \". found: \" + commentLength));\n      }\n      // 22 - Comment\n      // the encoding is always cp437.\n      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false)\n                                  : eocdrBuffer.slice(22);\n\n      if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {\n        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n      }\n\n      // ZIP64 format\n\n      // ZIP64 Zip64 end of central directory locator\n      var zip64EocdlBuffer = newBuffer(20);\n      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;\n      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {\n        if (err) return callback(err);\n\n        // 0 - zip64 end of central dir locator signature = 0x07064b50\n        if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {\n          return callback(new Error(\"invalid zip64 end of central directory locator signature\"));\n        }\n        // 4 - number of the disk with the start of the zip64 end of central directory\n        // 8 - relative offset of the zip64 end of central directory record\n        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);\n        // 16 - total number of disks\n\n        // ZIP64 end of central directory record\n        var zip64EocdrBuffer = newBuffer(56);\n        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {\n          if (err) return callback(err);\n\n          // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n          if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {\n            return callback(new Error(\"invalid zip64 end of central directory record signature\"));\n          }\n          // 4 - size of zip64 end of central directory record                8 bytes\n          // 12 - version made by                                             2 bytes\n          // 14 - version needed to extract                                   2 bytes\n          // 16 - number of this disk                                         4 bytes\n          // 20 - number of the disk with the start of the central directory  4 bytes\n          // 24 - total number of entries in the central directory on this disk         8 bytes\n          // 32 - total number of entries in the central directory            8 bytes\n          entryCount = readUInt64LE(zip64EocdrBuffer, 32);\n          // 40 - size of the central directory                               8 bytes\n          // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);\n          // 56 - zip64 extensible data sector                                (variable size)\n          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));\n        });\n      });\n      return;\n    }\n    callback(new Error(\"end of central directory record signature not found\"));\n  });\n}\n\nutil.inherits(ZipFile, EventEmitter);\nfunction ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {\n  var self = this;\n  EventEmitter.call(self);\n  self.reader = reader;\n  // forward close events\n  self.reader.on(\"error\", function(err) {\n    // error closing the fd\n    emitError(self, err);\n  });\n  self.reader.once(\"close\", function() {\n    self.emit(\"close\");\n  });\n  self.readEntryCursor = centralDirectoryOffset;\n  self.fileSize = fileSize;\n  self.entryCount = entryCount;\n  self.comment = comment;\n  self.entriesRead = 0;\n  self.autoClose = !!autoClose;\n  self.lazyEntries = !!lazyEntries;\n  self.decodeStrings = !!decodeStrings;\n  self.validateEntrySizes = !!validateEntrySizes;\n  self.strictFileNames = !!strictFileNames;\n  self.isOpen = true;\n  self.emittedError = false;\n\n  if (!self.lazyEntries) self._readEntry();\n}\nZipFile.prototype.close = function() {\n  if (!this.isOpen) return;\n  this.isOpen = false;\n  this.reader.unref();\n};\n\nfunction emitErrorAndAutoClose(self, err) {\n  if (self.autoClose) self.close();\n  emitError(self, err);\n}\nfunction emitError(self, err) {\n  if (self.emittedError) return;\n  self.emittedError = true;\n  self.emit(\"error\", err);\n}\n\nZipFile.prototype.readEntry = function() {\n  if (!this.lazyEntries) throw new Error(\"readEntry() called without lazyEntries:true\");\n  this._readEntry();\n};\nZipFile.prototype._readEntry = function() {\n  var self = this;\n  if (self.entryCount === self.entriesRead) {\n    // done with metadata\n    setImmediate(function() {\n      if (self.autoClose) self.close();\n      if (self.emittedError) return;\n      self.emit(\"end\");\n    });\n    return;\n  }\n  if (self.emittedError) return;\n  var buffer = newBuffer(46);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {\n    if (err) return emitErrorAndAutoClose(self, err);\n    if (self.emittedError) return;\n    var entry = new Entry();\n    // 0 - Central directory file header signature\n    var signature = buffer.readUInt32LE(0);\n    if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error(\"invalid central directory file header signature: 0x\" + signature.toString(16)));\n    // 4 - Version made by\n    entry.versionMadeBy = buffer.readUInt16LE(4);\n    // 6 - Version needed to extract (minimum)\n    entry.versionNeededToExtract = buffer.readUInt16LE(6);\n    // 8 - General purpose bit flag\n    entry.generalPurposeBitFlag = buffer.readUInt16LE(8);\n    // 10 - Compression method\n    entry.compressionMethod = buffer.readUInt16LE(10);\n    // 12 - File last modification time\n    entry.lastModFileTime = buffer.readUInt16LE(12);\n    // 14 - File last modification date\n    entry.lastModFileDate = buffer.readUInt16LE(14);\n    // 16 - CRC-32\n    entry.crc32 = buffer.readUInt32LE(16);\n    // 20 - Compressed size\n    entry.compressedSize = buffer.readUInt32LE(20);\n    // 24 - Uncompressed size\n    entry.uncompressedSize = buffer.readUInt32LE(24);\n    // 28 - File name length (n)\n    entry.fileNameLength = buffer.readUInt16LE(28);\n    // 30 - Extra field length (m)\n    entry.extraFieldLength = buffer.readUInt16LE(30);\n    // 32 - File comment length (k)\n    entry.fileCommentLength = buffer.readUInt16LE(32);\n    // 34 - Disk number where file starts\n    // 36 - Internal file attributes\n    entry.internalFileAttributes = buffer.readUInt16LE(36);\n    // 38 - External file attributes\n    entry.externalFileAttributes = buffer.readUInt32LE(38);\n    // 42 - Relative offset of local file header\n    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);\n\n    if (entry.generalPurposeBitFlag & 0x40) return emitErrorAndAutoClose(self, new Error(\"strong encryption is not supported\"));\n\n    self.readEntryCursor += 46;\n\n    buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);\n    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {\n      if (err) return emitErrorAndAutoClose(self, err);\n      if (self.emittedError) return;\n      // 46 - File name\n      var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;\n      entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8)\n                                          : buffer.slice(0, entry.fileNameLength);\n\n      // 46+n - Extra field\n      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;\n      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);\n      entry.extraFields = [];\n      var i = 0;\n      while (i < extraFieldBuffer.length - 3) {\n        var headerId = extraFieldBuffer.readUInt16LE(i + 0);\n        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);\n        var dataStart = i + 4;\n        var dataEnd = dataStart + dataSize;\n        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error(\"extra field length exceeds extra field buffer size\"));\n        var dataBuffer = newBuffer(dataSize);\n        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);\n        entry.extraFields.push({\n          id: headerId,\n          data: dataBuffer,\n        });\n        i = dataEnd;\n      }\n\n      // 46+n+m - File comment\n      entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8)\n                                             : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);\n      // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47\n      entry.comment = entry.fileComment;\n\n      self.readEntryCursor += buffer.length;\n      self.entriesRead += 1;\n\n      if (entry.uncompressedSize            === 0xffffffff ||\n          entry.compressedSize              === 0xffffffff ||\n          entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        // ZIP64 format\n        // find the Zip64 Extended Information Extra Field\n        var zip64EiefBuffer = null;\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n          if (extraField.id === 0x0001) {\n            zip64EiefBuffer = extraField.data;\n            break;\n          }\n        }\n        if (zip64EiefBuffer == null) {\n          return emitErrorAndAutoClose(self, new Error(\"expected zip64 extended information extra field\"));\n        }\n        var index = 0;\n        // 0 - Original Size          8 bytes\n        if (entry.uncompressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include uncompressed size\"));\n          }\n          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 8 - Compressed Size        8 bytes\n        if (entry.compressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include compressed size\"));\n          }\n          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 16 - Relative Header Offset 8 bytes\n        if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) {\n            return emitErrorAndAutoClose(self, new Error(\"zip64 extended information extra field does not include relative header offset\"));\n          }\n          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 24 - Disk Start Number      4 bytes\n      }\n\n      // check for Info-ZIP Unicode Path Extra Field (0x7075)\n      // see https://github.com/thejoshwolfe/yauzl/issues/33\n      if (self.decodeStrings) {\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n          if (extraField.id === 0x7075) {\n            if (extraField.data.length < 6) {\n              // too short to be meaningful\n              continue;\n            }\n            // Version       1 byte      version of this extra field, currently 1\n            if (extraField.data.readUInt8(0) !== 1) {\n              // > Changes may not be backward compatible so this extra\n              // > field should not be used if the version is not recognized.\n              continue;\n            }\n            // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n            var oldNameCrc32 = extraField.data.readUInt32LE(1);\n            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {\n              // > If the CRC check fails, this UTF-8 Path Extra Field should be\n              // > ignored and the File Name field in the header should be used instead.\n              continue;\n            }\n            // UnicodeName   Variable    UTF-8 version of the entry File Name\n            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);\n            break;\n          }\n        }\n      }\n\n      // validate file size\n      if (self.validateEntrySizes && entry.compressionMethod === 0) {\n        var expectedCompressedSize = entry.uncompressedSize;\n        if (entry.isEncrypted()) {\n          // traditional encryption prefixes the file data with a header\n          expectedCompressedSize += 12;\n        }\n        if (entry.compressedSize !== expectedCompressedSize) {\n          var msg = \"compressed/uncompressed size mismatch for stored file: \" + entry.compressedSize + \" != \" + entry.uncompressedSize;\n          return emitErrorAndAutoClose(self, new Error(msg));\n        }\n      }\n\n      if (self.decodeStrings) {\n        if (!self.strictFileNames) {\n          // allow backslash\n          entry.fileName = entry.fileName.replace(/\\\\/g, \"/\");\n        }\n        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);\n        if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));\n      }\n      self.emit(\"entry\", entry);\n\n      if (!self.lazyEntries) self._readEntry();\n    });\n  });\n};\n\nZipFile.prototype.openReadStream = function(entry, options, callback) {\n  var self = this;\n  // parameter validation\n  var relativeStart = 0;\n  var relativeEnd = entry.compressedSize;\n  if (callback == null) {\n    callback = options;\n    options = {};\n  } else {\n    // validate options that the caller has no excuse to get wrong\n    if (options.decrypt != null) {\n      if (!entry.isEncrypted()) {\n        throw new Error(\"options.decrypt can only be specified for encrypted entries\");\n      }\n      if (options.decrypt !== false) throw new Error(\"invalid options.decrypt value: \" + options.decrypt);\n      if (entry.isCompressed()) {\n        if (options.decompress !== false) throw new Error(\"entry is encrypted and compressed, and options.decompress !== false\");\n      }\n    }\n    if (options.decompress != null) {\n      if (!entry.isCompressed()) {\n        throw new Error(\"options.decompress can only be specified for compressed entries\");\n      }\n      if (!(options.decompress === false || options.decompress === true)) {\n        throw new Error(\"invalid options.decompress value: \" + options.decompress);\n      }\n    }\n    if (options.start != null || options.end != null) {\n      if (entry.isCompressed() && options.decompress !== false) {\n        throw new Error(\"start/end range not allowed for compressed entry without options.decompress === false\");\n      }\n      if (entry.isEncrypted() && options.decrypt !== false) {\n        throw new Error(\"start/end range not allowed for encrypted entry without options.decrypt === false\");\n      }\n    }\n    if (options.start != null) {\n      relativeStart = options.start;\n      if (relativeStart < 0) throw new Error(\"options.start < 0\");\n      if (relativeStart > entry.compressedSize) throw new Error(\"options.start > entry.compressedSize\");\n    }\n    if (options.end != null) {\n      relativeEnd = options.end;\n      if (relativeEnd < 0) throw new Error(\"options.end < 0\");\n      if (relativeEnd > entry.compressedSize) throw new Error(\"options.end > entry.compressedSize\");\n      if (relativeEnd < relativeStart) throw new Error(\"options.end < options.start\");\n    }\n  }\n  // any further errors can either be caused by the zipfile,\n  // or were introduced in a minor version of yauzl,\n  // so should be passed to the client rather than thrown.\n  if (!self.isOpen) return callback(new Error(\"closed\"));\n  if (entry.isEncrypted()) {\n    if (options.decrypt !== false) return callback(new Error(\"entry is encrypted, and options.decrypt !== false\"));\n  }\n  // make sure we don't lose the fd before we open the actual read stream\n  self.reader.ref();\n  var buffer = newBuffer(30);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {\n    try {\n      if (err) return callback(err);\n      // 0 - Local file header signature = 0x04034b50\n      var signature = buffer.readUInt32LE(0);\n      if (signature !== 0x04034b50) {\n        return callback(new Error(\"invalid local file header signature: 0x\" + signature.toString(16)));\n      }\n      // all this should be redundant\n      // 4 - Version needed to extract (minimum)\n      // 6 - General purpose bit flag\n      // 8 - Compression method\n      // 10 - File last modification time\n      // 12 - File last modification date\n      // 14 - CRC-32\n      // 18 - Compressed size\n      // 22 - Uncompressed size\n      // 26 - File name length (n)\n      var fileNameLength = buffer.readUInt16LE(26);\n      // 28 - Extra field length (m)\n      var extraFieldLength = buffer.readUInt16LE(28);\n      // 30 - File name\n      // 30+n - Extra field\n      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n      var decompress;\n      if (entry.compressionMethod === 0) {\n        // 0 - The file is stored (no compression)\n        decompress = false;\n      } else if (entry.compressionMethod === 8) {\n        // 8 - The file is Deflated\n        decompress = options.decompress != null ? options.decompress : true;\n      } else {\n        return callback(new Error(\"unsupported compression method: \" + entry.compressionMethod));\n      }\n      var fileDataStart = localFileHeaderEnd;\n      var fileDataEnd = fileDataStart + entry.compressedSize;\n      if (entry.compressedSize !== 0) {\n        // bounds check now, because the read streams will probably not complain loud enough.\n        // since we're dealing with an unsigned offset plus an unsigned size,\n        // we only have 1 thing to check for.\n        if (fileDataEnd > self.fileSize) {\n          return callback(new Error(\"file data overflows file bounds: \" +\n              fileDataStart + \" + \" + entry.compressedSize + \" > \" + self.fileSize));\n        }\n      }\n      var readStream = self.reader.createReadStream({\n        start: fileDataStart + relativeStart,\n        end: fileDataStart + relativeEnd,\n      });\n      var endpointStream = readStream;\n      if (decompress) {\n        var destroyed = false;\n        var inflateFilter = zlib.createInflateRaw();\n        readStream.on(\"error\", function(err) {\n          // setImmediate here because errors can be emitted during the first call to pipe()\n          setImmediate(function() {\n            if (!destroyed) inflateFilter.emit(\"error\", err);\n          });\n        });\n        readStream.pipe(inflateFilter);\n\n        if (self.validateEntrySizes) {\n          endpointStream = new AssertByteCountStream(entry.uncompressedSize);\n          inflateFilter.on(\"error\", function(err) {\n            // forward zlib errors to the client-visible stream\n            setImmediate(function() {\n              if (!destroyed) endpointStream.emit(\"error\", err);\n            });\n          });\n          inflateFilter.pipe(endpointStream);\n        } else {\n          // the zlib filter is the client-visible stream\n          endpointStream = inflateFilter;\n        }\n        // this is part of yauzl's API, so implement this function on the client-visible stream\n        endpointStream.destroy = function() {\n          destroyed = true;\n          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);\n          readStream.unpipe(inflateFilter);\n          // TODO: the inflateFilter may cause a memory leak. see Issue #27.\n          readStream.destroy();\n        };\n      }\n      callback(null, endpointStream);\n    } finally {\n      self.reader.unref();\n    }\n  });\n};\n\nfunction Entry() {\n}\nEntry.prototype.getLastModDate = function() {\n  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);\n};\nEntry.prototype.isEncrypted = function() {\n  return (this.generalPurposeBitFlag & 0x1) !== 0;\n};\nEntry.prototype.isCompressed = function() {\n  return this.compressionMethod === 8;\n};\n\nfunction dosDateTimeToDate(date, time) {\n  var day = date & 0x1f; // 1-31\n  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  var millisecond = 0;\n  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n  var minute = time >> 5 & 0x3f; // 0-59\n  var hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nfunction validateFileName(fileName) {\n  if (fileName.indexOf(\"\\\\\") !== -1) {\n    return \"invalid characters in fileName: \" + fileName;\n  }\n  if (/^[a-zA-Z]:/.test(fileName) || /^\\//.test(fileName)) {\n    return \"absolute path: \" + fileName;\n  }\n  if (fileName.split(\"/\").indexOf(\"..\") !== -1) {\n    return \"invalid relative path: \" + fileName;\n  }\n  // all good\n  return null;\n}\n\nfunction readAndAssertNoEof(reader, buffer, offset, length, position, callback) {\n  if (length === 0) {\n    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file\n    return setImmediate(function() { callback(null, newBuffer(0)); });\n  }\n  reader.read(buffer, offset, length, position, function(err, bytesRead) {\n    if (err) return callback(err);\n    if (bytesRead < length) {\n      return callback(new Error(\"unexpected EOF\"));\n    }\n    callback();\n  });\n}\n\nutil.inherits(AssertByteCountStream, Transform);\nfunction AssertByteCountStream(byteCount) {\n  Transform.call(this);\n  this.actualByteCount = 0;\n  this.expectedByteCount = byteCount;\n}\nAssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {\n  this.actualByteCount += chunk.length;\n  if (this.actualByteCount > this.expectedByteCount) {\n    var msg = \"too many bytes in the stream. expected \" + this.expectedByteCount + \". got at least \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n  cb(null, chunk);\n};\nAssertByteCountStream.prototype._flush = function(cb) {\n  if (this.actualByteCount < this.expectedByteCount) {\n    var msg = \"not enough bytes in the stream. expected \" + this.expectedByteCount + \". got only \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n  cb();\n};\n\nutil.inherits(RandomAccessReader, EventEmitter);\nfunction RandomAccessReader() {\n  EventEmitter.call(this);\n  this.refCount = 0;\n}\nRandomAccessReader.prototype.ref = function() {\n  this.refCount += 1;\n};\nRandomAccessReader.prototype.unref = function() {\n  var self = this;\n  self.refCount -= 1;\n\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  self.close(onCloseDone);\n\n  function onCloseDone(err) {\n    if (err) return self.emit('error', err);\n    self.emit('close');\n  }\n};\nRandomAccessReader.prototype.createReadStream = function(options) {\n  var start = options.start;\n  var end = options.end;\n  if (start === end) {\n    var emptyStream = new PassThrough();\n    setImmediate(function() {\n      emptyStream.end();\n    });\n    return emptyStream;\n  }\n  var stream = this._readStreamForRange(start, end);\n\n  var destroyed = false;\n  var refUnrefFilter = new RefUnrefFilter(this);\n  stream.on(\"error\", function(err) {\n    setImmediate(function() {\n      if (!destroyed) refUnrefFilter.emit(\"error\", err);\n    });\n  });\n  refUnrefFilter.destroy = function() {\n    stream.unpipe(refUnrefFilter);\n    refUnrefFilter.unref();\n    stream.destroy();\n  };\n\n  var byteCounter = new AssertByteCountStream(end - start);\n  refUnrefFilter.on(\"error\", function(err) {\n    setImmediate(function() {\n      if (!destroyed) byteCounter.emit(\"error\", err);\n    });\n  });\n  byteCounter.destroy = function() {\n    destroyed = true;\n    refUnrefFilter.unpipe(byteCounter);\n    refUnrefFilter.destroy();\n  };\n\n  return stream.pipe(refUnrefFilter).pipe(byteCounter);\n};\nRandomAccessReader.prototype._readStreamForRange = function(start, end) {\n  throw new Error(\"not implemented\");\n};\nRandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {\n  var readStream = this.createReadStream({start: position, end: position + length});\n  var writeStream = new Writable();\n  var written = 0;\n  writeStream._write = function(chunk, encoding, cb) {\n    chunk.copy(buffer, offset + written, 0, chunk.length);\n    written += chunk.length;\n    cb();\n  };\n  writeStream.on(\"finish\", callback);\n  readStream.on(\"error\", function(error) {\n    callback(error);\n  });\n  readStream.pipe(writeStream);\n};\nRandomAccessReader.prototype.close = function(callback) {\n  setImmediate(callback);\n};\n\nutil.inherits(RefUnrefFilter, PassThrough);\nfunction RefUnrefFilter(context) {\n  PassThrough.call(this);\n  this.context = context;\n  this.context.ref();\n  this.unreffedYet = false;\n}\nRefUnrefFilter.prototype._flush = function(cb) {\n  this.unref();\n  cb();\n};\nRefUnrefFilter.prototype.unref = function(cb) {\n  if (this.unreffedYet) return;\n  this.unreffedYet = true;\n  this.context.unref();\n};\n\nvar cp437 = '\\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';\nfunction decodeBuffer(buffer, start, end, isUtf8) {\n  if (isUtf8) {\n    return buffer.toString(\"utf8\", start, end);\n  } else {\n    var result = \"\";\n    for (var i = start; i < end; i++) {\n      result += cp437[buffer[i]];\n    }\n    return result;\n  }\n}\n\nfunction readUInt64LE(buffer, offset) {\n  // there is no native function for this, because we can't actually store 64-bit integers precisely.\n  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.\n  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.\n  var lower32 = buffer.readUInt32LE(offset);\n  var upper32 = buffer.readUInt32LE(offset + 4);\n  // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.\n  return upper32 * 0x100000000 + lower32;\n  // as long as we're bounds checking the result of this function against the total file size,\n  // we'll catch any overflow errors, because we already made sure the total file size was within reason.\n}\n\n// Node 10 deprecated new Buffer().\nvar newBuffer;\nif (typeof Buffer.allocUnsafe === \"function\") {\n  newBuffer = function(len) {\n    return Buffer.allocUnsafe(len);\n  };\n} else {\n  newBuffer = function(len) {\n    return new Buffer(len);\n  };\n}\n\nfunction defaultCallback(err) {\n  if (err) throw err;\n}\n"]},"metadata":{},"sourceType":"script"}