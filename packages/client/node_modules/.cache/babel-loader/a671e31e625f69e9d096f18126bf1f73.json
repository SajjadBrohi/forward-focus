{"ast":null,"code":"var chownr = require('chownr');\n\nvar tar = require('tar-stream');\n\nvar pump = require('pump');\n\nvar mkdirp = require('mkdirp-classic');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar os = require('os');\n\nvar win32 = os.platform() === 'win32';\n\nvar noop = function () {};\n\nvar echo = function (name) {\n  return name;\n};\n\nvar normalize = !win32 ? echo : function (name) {\n  return name.replace(/\\\\/g, '/').replace(/[:?<>|]/g, '_');\n};\n\nvar statAll = function (fs, stat, cwd, ignore, entries, sort) {\n  var queue = entries || ['.'];\n  return function loop(callback) {\n    if (!queue.length) return callback();\n    var next = queue.shift();\n    var nextAbs = path.join(cwd, next);\n    stat(nextAbs, function (err, stat) {\n      if (err) return callback(err);\n      if (!stat.isDirectory()) return callback(null, next, stat);\n      fs.readdir(nextAbs, function (err, files) {\n        if (err) return callback(err);\n        if (sort) files.sort();\n\n        for (var i = 0; i < files.length; i++) {\n          if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]));\n        }\n\n        callback(null, next, stat);\n      });\n    });\n  };\n};\n\nvar strip = function (map, level) {\n  return function (header) {\n    header.name = header.name.split('/').slice(level).join('/');\n    var linkname = header.linkname;\n\n    if (linkname && (header.type === 'link' || path.isAbsolute(linkname))) {\n      header.linkname = linkname.split('/').slice(level).join('/');\n    }\n\n    return map(header);\n  };\n};\n\nexports.pack = function (cwd, opts) {\n  if (!cwd) cwd = '.';\n  if (!opts) opts = {};\n  var xfs = opts.fs || fs;\n  var ignore = opts.ignore || opts.filter || noop;\n  var map = opts.map || noop;\n  var mapStream = opts.mapStream || echo;\n  var statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort);\n  var strict = opts.strict !== false;\n  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask();\n  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0;\n  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0;\n  var pack = opts.pack || tar.pack();\n  var finish = opts.finish || noop;\n  if (opts.strip) map = strip(map, opts.strip);\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8);\n    fmode |= parseInt(444, 8);\n  }\n\n  if (opts.writable) {\n    dmode |= parseInt(333, 8);\n    fmode |= parseInt(222, 8);\n  }\n\n  var onsymlink = function (filename, header) {\n    xfs.readlink(path.join(cwd, filename), function (err, linkname) {\n      if (err) return pack.destroy(err);\n      header.linkname = normalize(linkname);\n      pack.entry(header, onnextentry);\n    });\n  };\n\n  var onstat = function (err, filename, stat) {\n    if (err) return pack.destroy(err);\n\n    if (!filename) {\n      if (opts.finalize !== false) pack.finalize();\n      return finish(pack);\n    }\n\n    if (stat.isSocket()) return onnextentry(); // tar does not support sockets...\n\n    var header = {\n      name: normalize(filename),\n      mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,\n      mtime: stat.mtime,\n      size: stat.size,\n      type: 'file',\n      uid: stat.uid,\n      gid: stat.gid\n    };\n\n    if (stat.isDirectory()) {\n      header.size = 0;\n      header.type = 'directory';\n      header = map(header) || header;\n      return pack.entry(header, onnextentry);\n    }\n\n    if (stat.isSymbolicLink()) {\n      header.size = 0;\n      header.type = 'symlink';\n      header = map(header) || header;\n      return onsymlink(filename, header);\n    } // TODO: add fifo etc...\n\n\n    header = map(header) || header;\n\n    if (!stat.isFile()) {\n      if (strict) return pack.destroy(new Error('unsupported type for ' + filename));\n      return onnextentry();\n    }\n\n    var entry = pack.entry(header, onnextentry);\n    if (!entry) return;\n    var rs = mapStream(xfs.createReadStream(path.join(cwd, filename), {\n      start: 0,\n      end: header.size > 0 ? header.size - 1 : header.size\n    }), header);\n    rs.on('error', function (err) {\n      // always forward errors on destroy\n      entry.destroy(err);\n    });\n    pump(rs, entry);\n  };\n\n  var onnextentry = function (err) {\n    if (err) return pack.destroy(err);\n    statNext(onstat);\n  };\n\n  onnextentry();\n  return pack;\n};\n\nvar head = function (list) {\n  return list.length ? list[list.length - 1] : null;\n};\n\nvar processGetuid = function () {\n  return process.getuid ? process.getuid() : -1;\n};\n\nvar processUmask = function () {\n  return process.umask ? process.umask() : 0;\n};\n\nexports.extract = function (cwd, opts) {\n  if (!cwd) cwd = '.';\n  if (!opts) opts = {};\n  var xfs = opts.fs || fs;\n  var ignore = opts.ignore || opts.filter || noop;\n  var map = opts.map || noop;\n  var mapStream = opts.mapStream || echo;\n  var own = opts.chown !== false && !win32 && processGetuid() === 0;\n  var extract = opts.extract || tar.extract();\n  var stack = [];\n  var now = new Date();\n  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask();\n  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0;\n  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0;\n  var strict = opts.strict !== false;\n  if (opts.strip) map = strip(map, opts.strip);\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8);\n    fmode |= parseInt(444, 8);\n  }\n\n  if (opts.writable) {\n    dmode |= parseInt(333, 8);\n    fmode |= parseInt(222, 8);\n  }\n\n  var utimesParent = function (name, cb) {\n    // we just set the mtime on the parent dir again everytime we write an entry\n    var top;\n\n    while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop();\n\n    if (!top) return cb();\n    xfs.utimes(top[0], now, top[1], cb);\n  };\n\n  var utimes = function (name, header, cb) {\n    if (opts.utimes === false) return cb();\n    if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb);\n    if (header.type === 'symlink') return utimesParent(name, cb); // TODO: how to set mtime on link?\n\n    xfs.utimes(name, now, header.mtime, function (err) {\n      if (err) return cb(err);\n      utimesParent(name, cb);\n    });\n  };\n\n  var chperm = function (name, header, cb) {\n    var link = header.type === 'symlink';\n    /* eslint-disable node/no-deprecated-api */\n\n    var chmod = link ? xfs.lchmod : xfs.chmod;\n    var chown = link ? xfs.lchown : xfs.chown;\n    /* eslint-enable node/no-deprecated-api */\n\n    if (!chmod) return cb();\n    var mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask;\n    chmod(name, mode, function (err) {\n      if (err) return cb(err);\n      if (!own) return cb();\n      if (!chown) return cb();\n      chown(name, header.uid, header.gid, cb);\n    });\n  };\n\n  extract.on('entry', function (header, stream, next) {\n    header = map(header) || header;\n    header.name = normalize(header.name);\n    var name = path.join(cwd, path.join('/', header.name));\n\n    if (ignore(name, header)) {\n      stream.resume();\n      return next();\n    }\n\n    var stat = function (err) {\n      if (err) return next(err);\n      utimes(name, header, function (err) {\n        if (err) return next(err);\n        if (win32) return next();\n        chperm(name, header, next);\n      });\n    };\n\n    var onsymlink = function () {\n      if (win32) return next(); // skip symlinks on win for now before it can be tested\n\n      xfs.unlink(name, function () {\n        xfs.symlink(header.linkname, name, stat);\n      });\n    };\n\n    var onlink = function () {\n      if (win32) return next(); // skip links on win for now before it can be tested\n\n      xfs.unlink(name, function () {\n        var srcpath = path.join(cwd, path.join('/', header.linkname));\n        xfs.link(srcpath, name, function (err) {\n          if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {\n            stream = xfs.createReadStream(srcpath);\n            return onfile();\n          }\n\n          stat(err);\n        });\n      });\n    };\n\n    var onfile = function () {\n      var ws = xfs.createWriteStream(name);\n      var rs = mapStream(stream, header);\n      ws.on('error', function (err) {\n        // always forward errors on destroy\n        rs.destroy(err);\n      });\n      pump(rs, ws, function (err) {\n        if (err) return next(err);\n        ws.on('close', stat);\n      });\n    };\n\n    if (header.type === 'directory') {\n      stack.push([name, header.mtime]);\n      return mkdirfix(name, {\n        fs: xfs,\n        own: own,\n        uid: header.uid,\n        gid: header.gid\n      }, stat);\n    }\n\n    var dir = path.dirname(name);\n    validate(xfs, dir, path.join(cwd, '.'), function (err, valid) {\n      if (err) return next(err);\n      if (!valid) return next(new Error(dir + ' is not a valid path'));\n      mkdirfix(dir, {\n        fs: xfs,\n        own: own,\n        uid: header.uid,\n        gid: header.gid\n      }, function (err) {\n        if (err) return next(err);\n\n        switch (header.type) {\n          case 'file':\n            return onfile();\n\n          case 'link':\n            return onlink();\n\n          case 'symlink':\n            return onsymlink();\n        }\n\n        if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'));\n        stream.resume();\n        next();\n      });\n    });\n  });\n  if (opts.finish) extract.on('finish', opts.finish);\n  return extract;\n};\n\nfunction validate(fs, name, root, cb) {\n  if (name === root) return cb(null, true);\n  fs.lstat(name, function (err, st) {\n    if (err && err.code !== 'ENOENT') return cb(err);\n    if (err || st.isDirectory()) return validate(fs, path.join(name, '..'), root, cb);\n    cb(null, false);\n  });\n}\n\nfunction mkdirfix(name, opts, cb) {\n  mkdirp(name, {\n    fs: opts.fs\n  }, function (err, made) {\n    if (!err && made && opts.own) {\n      chownr(made, opts.uid, opts.gid, cb);\n    } else {\n      cb(err);\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/Sajjad Brohi/JavaScript Projects/RESTful API/packages/client/node_modules/tar-fs/index.js"],"names":["chownr","require","tar","pump","mkdirp","fs","path","os","win32","platform","noop","echo","name","normalize","replace","statAll","stat","cwd","ignore","entries","sort","queue","loop","callback","length","next","shift","nextAbs","join","err","isDirectory","readdir","files","i","push","strip","map","level","header","split","slice","linkname","type","isAbsolute","exports","pack","opts","xfs","filter","mapStream","statNext","dereference","lstat","strict","umask","processUmask","dmode","fmode","finish","readable","parseInt","writable","onsymlink","filename","readlink","destroy","entry","onnextentry","onstat","finalize","isSocket","mode","mtime","size","uid","gid","isSymbolicLink","isFile","Error","rs","createReadStream","start","end","on","head","list","processGetuid","process","getuid","extract","own","chown","stack","now","Date","utimesParent","cb","top","pop","utimes","chperm","link","chmod","lchmod","lchown","stream","resume","unlink","symlink","onlink","srcpath","code","hardlinkAsFilesFallback","onfile","ws","createWriteStream","mkdirfix","dir","dirname","validate","valid","root","st","made"],"mappings":"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","sourcesContent":["var chownr = require('chownr')\nvar tar = require('tar-stream')\nvar pump = require('pump')\nvar mkdirp = require('mkdirp-classic')\nvar fs = require('fs')\nvar path = require('path')\nvar os = require('os')\n\nvar win32 = os.platform() === 'win32'\n\nvar noop = function () {}\n\nvar echo = function (name) {\n  return name\n}\n\nvar normalize = !win32 ? echo : function (name) {\n  return name.replace(/\\\\/g, '/').replace(/[:?<>|]/g, '_')\n}\n\nvar statAll = function (fs, stat, cwd, ignore, entries, sort) {\n  var queue = entries || ['.']\n\n  return function loop (callback) {\n    if (!queue.length) return callback()\n    var next = queue.shift()\n    var nextAbs = path.join(cwd, next)\n\n    stat(nextAbs, function (err, stat) {\n      if (err) return callback(err)\n\n      if (!stat.isDirectory()) return callback(null, next, stat)\n\n      fs.readdir(nextAbs, function (err, files) {\n        if (err) return callback(err)\n\n        if (sort) files.sort()\n        for (var i = 0; i < files.length; i++) {\n          if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]))\n        }\n\n        callback(null, next, stat)\n      })\n    })\n  }\n}\n\nvar strip = function (map, level) {\n  return function (header) {\n    header.name = header.name.split('/').slice(level).join('/')\n\n    var linkname = header.linkname\n    if (linkname && (header.type === 'link' || path.isAbsolute(linkname))) {\n      header.linkname = linkname.split('/').slice(level).join('/')\n    }\n\n    return map(header)\n  }\n}\n\nexports.pack = function (cwd, opts) {\n  if (!cwd) cwd = '.'\n  if (!opts) opts = {}\n\n  var xfs = opts.fs || fs\n  var ignore = opts.ignore || opts.filter || noop\n  var map = opts.map || noop\n  var mapStream = opts.mapStream || echo\n  var statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort)\n  var strict = opts.strict !== false\n  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()\n  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0\n  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0\n  var pack = opts.pack || tar.pack()\n  var finish = opts.finish || noop\n\n  if (opts.strip) map = strip(map, opts.strip)\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8)\n    fmode |= parseInt(444, 8)\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8)\n    fmode |= parseInt(222, 8)\n  }\n\n  var onsymlink = function (filename, header) {\n    xfs.readlink(path.join(cwd, filename), function (err, linkname) {\n      if (err) return pack.destroy(err)\n      header.linkname = normalize(linkname)\n      pack.entry(header, onnextentry)\n    })\n  }\n\n  var onstat = function (err, filename, stat) {\n    if (err) return pack.destroy(err)\n    if (!filename) {\n      if (opts.finalize !== false) pack.finalize()\n      return finish(pack)\n    }\n\n    if (stat.isSocket()) return onnextentry() // tar does not support sockets...\n\n    var header = {\n      name: normalize(filename),\n      mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,\n      mtime: stat.mtime,\n      size: stat.size,\n      type: 'file',\n      uid: stat.uid,\n      gid: stat.gid\n    }\n\n    if (stat.isDirectory()) {\n      header.size = 0\n      header.type = 'directory'\n      header = map(header) || header\n      return pack.entry(header, onnextentry)\n    }\n\n    if (stat.isSymbolicLink()) {\n      header.size = 0\n      header.type = 'symlink'\n      header = map(header) || header\n      return onsymlink(filename, header)\n    }\n\n    // TODO: add fifo etc...\n\n    header = map(header) || header\n\n    if (!stat.isFile()) {\n      if (strict) return pack.destroy(new Error('unsupported type for ' + filename))\n      return onnextentry()\n    }\n\n    var entry = pack.entry(header, onnextentry)\n    if (!entry) return\n\n    var rs = mapStream(xfs.createReadStream(path.join(cwd, filename), { start: 0, end: header.size > 0 ? header.size - 1 : header.size }), header)\n\n    rs.on('error', function (err) { // always forward errors on destroy\n      entry.destroy(err)\n    })\n\n    pump(rs, entry)\n  }\n\n  var onnextentry = function (err) {\n    if (err) return pack.destroy(err)\n    statNext(onstat)\n  }\n\n  onnextentry()\n\n  return pack\n}\n\nvar head = function (list) {\n  return list.length ? list[list.length - 1] : null\n}\n\nvar processGetuid = function () {\n  return process.getuid ? process.getuid() : -1\n}\n\nvar processUmask = function () {\n  return process.umask ? process.umask() : 0\n}\n\nexports.extract = function (cwd, opts) {\n  if (!cwd) cwd = '.'\n  if (!opts) opts = {}\n\n  var xfs = opts.fs || fs\n  var ignore = opts.ignore || opts.filter || noop\n  var map = opts.map || noop\n  var mapStream = opts.mapStream || echo\n  var own = opts.chown !== false && !win32 && processGetuid() === 0\n  var extract = opts.extract || tar.extract()\n  var stack = []\n  var now = new Date()\n  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()\n  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0\n  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0\n  var strict = opts.strict !== false\n\n  if (opts.strip) map = strip(map, opts.strip)\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8)\n    fmode |= parseInt(444, 8)\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8)\n    fmode |= parseInt(222, 8)\n  }\n\n  var utimesParent = function (name, cb) { // we just set the mtime on the parent dir again everytime we write an entry\n    var top\n    while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop()\n    if (!top) return cb()\n    xfs.utimes(top[0], now, top[1], cb)\n  }\n\n  var utimes = function (name, header, cb) {\n    if (opts.utimes === false) return cb()\n\n    if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb)\n    if (header.type === 'symlink') return utimesParent(name, cb) // TODO: how to set mtime on link?\n\n    xfs.utimes(name, now, header.mtime, function (err) {\n      if (err) return cb(err)\n      utimesParent(name, cb)\n    })\n  }\n\n  var chperm = function (name, header, cb) {\n    var link = header.type === 'symlink'\n\n    /* eslint-disable node/no-deprecated-api */\n    var chmod = link ? xfs.lchmod : xfs.chmod\n    var chown = link ? xfs.lchown : xfs.chown\n    /* eslint-enable node/no-deprecated-api */\n\n    if (!chmod) return cb()\n\n    var mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask\n    chmod(name, mode, function (err) {\n      if (err) return cb(err)\n      if (!own) return cb()\n      if (!chown) return cb()\n      chown(name, header.uid, header.gid, cb)\n    })\n  }\n\n  extract.on('entry', function (header, stream, next) {\n    header = map(header) || header\n    header.name = normalize(header.name)\n    var name = path.join(cwd, path.join('/', header.name))\n\n    if (ignore(name, header)) {\n      stream.resume()\n      return next()\n    }\n\n    var stat = function (err) {\n      if (err) return next(err)\n      utimes(name, header, function (err) {\n        if (err) return next(err)\n        if (win32) return next()\n        chperm(name, header, next)\n      })\n    }\n\n    var onsymlink = function () {\n      if (win32) return next() // skip symlinks on win for now before it can be tested\n      xfs.unlink(name, function () {\n        xfs.symlink(header.linkname, name, stat)\n      })\n    }\n\n    var onlink = function () {\n      if (win32) return next() // skip links on win for now before it can be tested\n      xfs.unlink(name, function () {\n        var srcpath = path.join(cwd, path.join('/', header.linkname))\n\n        xfs.link(srcpath, name, function (err) {\n          if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {\n            stream = xfs.createReadStream(srcpath)\n            return onfile()\n          }\n\n          stat(err)\n        })\n      })\n    }\n\n    var onfile = function () {\n      var ws = xfs.createWriteStream(name)\n      var rs = mapStream(stream, header)\n\n      ws.on('error', function (err) { // always forward errors on destroy\n        rs.destroy(err)\n      })\n\n      pump(rs, ws, function (err) {\n        if (err) return next(err)\n        ws.on('close', stat)\n      })\n    }\n\n    if (header.type === 'directory') {\n      stack.push([name, header.mtime])\n      return mkdirfix(name, {\n        fs: xfs, own: own, uid: header.uid, gid: header.gid\n      }, stat)\n    }\n\n    var dir = path.dirname(name)\n\n    validate(xfs, dir, path.join(cwd, '.'), function (err, valid) {\n      if (err) return next(err)\n      if (!valid) return next(new Error(dir + ' is not a valid path'))\n\n      mkdirfix(dir, {\n        fs: xfs, own: own, uid: header.uid, gid: header.gid\n      }, function (err) {\n        if (err) return next(err)\n\n        switch (header.type) {\n          case 'file': return onfile()\n          case 'link': return onlink()\n          case 'symlink': return onsymlink()\n        }\n\n        if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'))\n\n        stream.resume()\n        next()\n      })\n    })\n  })\n\n  if (opts.finish) extract.on('finish', opts.finish)\n\n  return extract\n}\n\nfunction validate (fs, name, root, cb) {\n  if (name === root) return cb(null, true)\n  fs.lstat(name, function (err, st) {\n    if (err && err.code !== 'ENOENT') return cb(err)\n    if (err || st.isDirectory()) return validate(fs, path.join(name, '..'), root, cb)\n    cb(null, false)\n  })\n}\n\nfunction mkdirfix (name, opts, cb) {\n  mkdirp(name, { fs: opts.fs }, function (err, made) {\n    if (!err && made && opts.own) {\n      chownr(made, opts.uid, opts.gid, cb)\n    } else {\n      cb(err)\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}