{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NetworkManager = exports.NetworkManagerEmittedEvents = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst HTTPRequest_js_1 = require(\"./HTTPRequest.js\");\n\nconst HTTPResponse_js_1 = require(\"./HTTPResponse.js\");\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\n\n\nexports.NetworkManagerEmittedEvents = {\n  Request: Symbol('NetworkManager.Request'),\n  Response: Symbol('NetworkManager.Response'),\n  RequestFailed: Symbol('NetworkManager.RequestFailed'),\n  RequestFinished: Symbol('NetworkManager.RequestFinished')\n};\n/**\n * @internal\n */\n\nclass NetworkManager extends EventEmitter_js_1.EventEmitter {\n  constructor(client, ignoreHTTPSErrors, frameManager) {\n    super();\n    this._requestIdToRequest = new Map();\n    this._requestIdToRequestWillBeSentEvent = new Map();\n    this._extraHTTPHeaders = {};\n    this._offline = false;\n    this._credentials = null;\n    this._attemptedAuthentications = new Set();\n    this._userRequestInterceptionEnabled = false;\n    this._protocolRequestInterceptionEnabled = false;\n    this._userCacheDisabled = false;\n    this._requestIdToInterceptionId = new Map();\n    this._client = client;\n    this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this._frameManager = frameManager;\n\n    this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));\n\n    this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));\n\n    this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n\n    this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n\n    this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n\n    this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n\n    this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n  }\n\n  async initialize() {\n    await this._client.send('Network.enable');\n    if (this._ignoreHTTPSErrors) await this._client.send('Security.setIgnoreCertificateErrors', {\n      ignore: true\n    });\n  }\n\n  async authenticate(credentials) {\n    this._credentials = credentials;\n    await this._updateProtocolRequestInterception();\n  }\n\n  async setExtraHTTPHeaders(extraHTTPHeaders) {\n    this._extraHTTPHeaders = {};\n\n    for (const key of Object.keys(extraHTTPHeaders)) {\n      const value = extraHTTPHeaders[key];\n      assert_js_1.assert(helper_js_1.helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n      this._extraHTTPHeaders[key.toLowerCase()] = value;\n    }\n\n    await this._client.send('Network.setExtraHTTPHeaders', {\n      headers: this._extraHTTPHeaders\n    });\n  }\n\n  extraHTTPHeaders() {\n    return Object.assign({}, this._extraHTTPHeaders);\n  }\n\n  async setOfflineMode(value) {\n    if (this._offline === value) return;\n    this._offline = value;\n    await this._client.send('Network.emulateNetworkConditions', {\n      offline: this._offline,\n      // values of 0 remove any active throttling. crbug.com/456324#c9\n      latency: 0,\n      downloadThroughput: -1,\n      uploadThroughput: -1\n    });\n  }\n\n  async setUserAgent(userAgent) {\n    await this._client.send('Network.setUserAgentOverride', {\n      userAgent\n    });\n  }\n\n  async setCacheEnabled(enabled) {\n    this._userCacheDisabled = !enabled;\n    await this._updateProtocolCacheDisabled();\n  }\n\n  async setRequestInterception(value) {\n    this._userRequestInterceptionEnabled = value;\n    await this._updateProtocolRequestInterception();\n  }\n\n  async _updateProtocolRequestInterception() {\n    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n    if (enabled === this._protocolRequestInterceptionEnabled) return;\n    this._protocolRequestInterceptionEnabled = enabled;\n\n    if (enabled) {\n      await Promise.all([this._updateProtocolCacheDisabled(), this._client.send('Fetch.enable', {\n        handleAuthRequests: true,\n        patterns: [{\n          urlPattern: '*'\n        }]\n      })]);\n    } else {\n      await Promise.all([this._updateProtocolCacheDisabled(), this._client.send('Fetch.disable')]);\n    }\n  }\n\n  async _updateProtocolCacheDisabled() {\n    await this._client.send('Network.setCacheDisabled', {\n      cacheDisabled: this._userCacheDisabled || this._protocolRequestInterceptionEnabled\n    });\n  }\n\n  _onRequestWillBeSent(event) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {\n      const requestId = event.requestId;\n\n      const interceptionId = this._requestIdToInterceptionId.get(requestId);\n\n      if (interceptionId) {\n        this._onRequest(event, interceptionId);\n\n        this._requestIdToInterceptionId.delete(requestId);\n      } else {\n        this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);\n      }\n\n      return;\n    }\n\n    this._onRequest(event, null);\n  }\n\n  _onAuthRequired(event) {\n    let response = 'Default';\n\n    if (this._attemptedAuthentications.has(event.requestId)) {\n      response = 'CancelAuth';\n    } else if (this._credentials) {\n      response = 'ProvideCredentials';\n\n      this._attemptedAuthentications.add(event.requestId);\n    }\n\n    const {\n      username,\n      password\n    } = this._credentials || {\n      username: undefined,\n      password: undefined\n    };\n\n    this._client.send('Fetch.continueWithAuth', {\n      requestId: event.requestId,\n      authChallengeResponse: {\n        response,\n        username,\n        password\n      }\n    }).catch(helper_js_1.debugError);\n  }\n\n  _onRequestPaused(event) {\n    if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {\n      this._client.send('Fetch.continueRequest', {\n        requestId: event.requestId\n      }).catch(helper_js_1.debugError);\n    }\n\n    const requestId = event.networkId;\n    const interceptionId = event.requestId;\n\n    if (requestId && this._requestIdToRequestWillBeSentEvent.has(requestId)) {\n      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n\n      this._onRequest(requestWillBeSentEvent, interceptionId);\n\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n    } else {\n      this._requestIdToInterceptionId.set(requestId, interceptionId);\n    }\n  }\n\n  _onRequest(event, interceptionId) {\n    let redirectChain = [];\n\n    if (event.redirectResponse) {\n      const request = this._requestIdToRequest.get(event.requestId); // If we connect late to the target, we could have missed the\n      // requestWillBeSent event.\n\n\n      if (request) {\n        this._handleRequestRedirect(request, event.redirectResponse);\n\n        redirectChain = request._redirectChain;\n      }\n    }\n\n    const frame = event.frameId ? this._frameManager.frame(event.frameId) : null;\n    const request = new HTTPRequest_js_1.HTTPRequest(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n\n    this._requestIdToRequest.set(event.requestId, request);\n\n    this.emit(exports.NetworkManagerEmittedEvents.Request, request);\n  }\n\n  _onRequestServedFromCache(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n\n    if (request) request._fromMemoryCache = true;\n  }\n\n  _handleRequestRedirect(request, responsePayload) {\n    const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, responsePayload);\n    request._response = response;\n\n    request._redirectChain.push(request);\n\n    response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n\n    this._requestIdToRequest.delete(request._requestId);\n\n    this._attemptedAuthentications.delete(request._interceptionId);\n\n    this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n    this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n\n  _onResponseReceived(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // FileUpload sends a response without a matching request.\n\n\n    if (!request) return;\n    const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, event.response);\n    request._response = response;\n    this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n  }\n\n  _onLoadingFinished(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return; // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n\n    if (request.response()) request.response()._resolveBody(null);\n\n    this._requestIdToRequest.delete(request._requestId);\n\n    this._attemptedAuthentications.delete(request._interceptionId);\n\n    this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n\n  _onLoadingFailed(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return;\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response) response._resolveBody(null);\n\n    this._requestIdToRequest.delete(request._requestId);\n\n    this._attemptedAuthentications.delete(request._interceptionId);\n\n    this.emit(exports.NetworkManagerEmittedEvents.RequestFailed, request);\n  }\n\n}\n\nexports.NetworkManager = NetworkManager;","map":{"version":3,"sources":["C:/Users/Sajjad Brohi/JavaScript Projects/RESTful API/packages/client/node_modules/puppeteer/lib/cjs/puppeteer/common/NetworkManager.js"],"names":["Object","defineProperty","exports","value","NetworkManager","NetworkManagerEmittedEvents","EventEmitter_js_1","require","assert_js_1","helper_js_1","HTTPRequest_js_1","HTTPResponse_js_1","Request","Symbol","Response","RequestFailed","RequestFinished","EventEmitter","constructor","client","ignoreHTTPSErrors","frameManager","_requestIdToRequest","Map","_requestIdToRequestWillBeSentEvent","_extraHTTPHeaders","_offline","_credentials","_attemptedAuthentications","Set","_userRequestInterceptionEnabled","_protocolRequestInterceptionEnabled","_userCacheDisabled","_requestIdToInterceptionId","_client","_ignoreHTTPSErrors","_frameManager","on","_onRequestPaused","bind","_onAuthRequired","_onRequestWillBeSent","_onRequestServedFromCache","_onResponseReceived","_onLoadingFinished","_onLoadingFailed","initialize","send","ignore","authenticate","credentials","_updateProtocolRequestInterception","setExtraHTTPHeaders","extraHTTPHeaders","key","keys","assert","helper","isString","toLowerCase","headers","assign","setOfflineMode","offline","latency","downloadThroughput","uploadThroughput","setUserAgent","userAgent","setCacheEnabled","enabled","_updateProtocolCacheDisabled","setRequestInterception","Promise","all","handleAuthRequests","patterns","urlPattern","cacheDisabled","event","request","url","startsWith","requestId","interceptionId","get","_onRequest","delete","set","response","has","add","username","password","undefined","authChallengeResponse","catch","debugError","networkId","requestWillBeSentEvent","redirectChain","redirectResponse","_handleRequestRedirect","_redirectChain","frame","frameId","HTTPRequest","emit","_fromMemoryCache","responsePayload","HTTPResponse","_response","push","_resolveBody","Error","_requestId","_interceptionId","_failureText","errorText"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NetworkManager = exports.NetworkManagerEmittedEvents = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst HTTPRequest_js_1 = require(\"./HTTPRequest.js\");\nconst HTTPResponse_js_1 = require(\"./HTTPResponse.js\");\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexports.NetworkManagerEmittedEvents = {\n    Request: Symbol('NetworkManager.Request'),\n    Response: Symbol('NetworkManager.Response'),\n    RequestFailed: Symbol('NetworkManager.RequestFailed'),\n    RequestFinished: Symbol('NetworkManager.RequestFinished'),\n};\n/**\n * @internal\n */\nclass NetworkManager extends EventEmitter_js_1.EventEmitter {\n    constructor(client, ignoreHTTPSErrors, frameManager) {\n        super();\n        this._requestIdToRequest = new Map();\n        this._requestIdToRequestWillBeSentEvent = new Map();\n        this._extraHTTPHeaders = {};\n        this._offline = false;\n        this._credentials = null;\n        this._attemptedAuthentications = new Set();\n        this._userRequestInterceptionEnabled = false;\n        this._protocolRequestInterceptionEnabled = false;\n        this._userCacheDisabled = false;\n        this._requestIdToInterceptionId = new Map();\n        this._client = client;\n        this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n        this._frameManager = frameManager;\n        this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));\n        this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));\n        this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n        this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n        this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n        this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n        this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n    }\n    async initialize() {\n        await this._client.send('Network.enable');\n        if (this._ignoreHTTPSErrors)\n            await this._client.send('Security.setIgnoreCertificateErrors', {\n                ignore: true,\n            });\n    }\n    async authenticate(credentials) {\n        this._credentials = credentials;\n        await this._updateProtocolRequestInterception();\n    }\n    async setExtraHTTPHeaders(extraHTTPHeaders) {\n        this._extraHTTPHeaders = {};\n        for (const key of Object.keys(extraHTTPHeaders)) {\n            const value = extraHTTPHeaders[key];\n            assert_js_1.assert(helper_js_1.helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n            this._extraHTTPHeaders[key.toLowerCase()] = value;\n        }\n        await this._client.send('Network.setExtraHTTPHeaders', {\n            headers: this._extraHTTPHeaders,\n        });\n    }\n    extraHTTPHeaders() {\n        return Object.assign({}, this._extraHTTPHeaders);\n    }\n    async setOfflineMode(value) {\n        if (this._offline === value)\n            return;\n        this._offline = value;\n        await this._client.send('Network.emulateNetworkConditions', {\n            offline: this._offline,\n            // values of 0 remove any active throttling. crbug.com/456324#c9\n            latency: 0,\n            downloadThroughput: -1,\n            uploadThroughput: -1,\n        });\n    }\n    async setUserAgent(userAgent) {\n        await this._client.send('Network.setUserAgentOverride', { userAgent });\n    }\n    async setCacheEnabled(enabled) {\n        this._userCacheDisabled = !enabled;\n        await this._updateProtocolCacheDisabled();\n    }\n    async setRequestInterception(value) {\n        this._userRequestInterceptionEnabled = value;\n        await this._updateProtocolRequestInterception();\n    }\n    async _updateProtocolRequestInterception() {\n        const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n        if (enabled === this._protocolRequestInterceptionEnabled)\n            return;\n        this._protocolRequestInterceptionEnabled = enabled;\n        if (enabled) {\n            await Promise.all([\n                this._updateProtocolCacheDisabled(),\n                this._client.send('Fetch.enable', {\n                    handleAuthRequests: true,\n                    patterns: [{ urlPattern: '*' }],\n                }),\n            ]);\n        }\n        else {\n            await Promise.all([\n                this._updateProtocolCacheDisabled(),\n                this._client.send('Fetch.disable'),\n            ]);\n        }\n    }\n    async _updateProtocolCacheDisabled() {\n        await this._client.send('Network.setCacheDisabled', {\n            cacheDisabled: this._userCacheDisabled || this._protocolRequestInterceptionEnabled,\n        });\n    }\n    _onRequestWillBeSent(event) {\n        // Request interception doesn't happen for data URLs with Network Service.\n        if (this._protocolRequestInterceptionEnabled &&\n            !event.request.url.startsWith('data:')) {\n            const requestId = event.requestId;\n            const interceptionId = this._requestIdToInterceptionId.get(requestId);\n            if (interceptionId) {\n                this._onRequest(event, interceptionId);\n                this._requestIdToInterceptionId.delete(requestId);\n            }\n            else {\n                this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);\n            }\n            return;\n        }\n        this._onRequest(event, null);\n    }\n    _onAuthRequired(event) {\n        let response = 'Default';\n        if (this._attemptedAuthentications.has(event.requestId)) {\n            response = 'CancelAuth';\n        }\n        else if (this._credentials) {\n            response = 'ProvideCredentials';\n            this._attemptedAuthentications.add(event.requestId);\n        }\n        const { username, password } = this._credentials || {\n            username: undefined,\n            password: undefined,\n        };\n        this._client\n            .send('Fetch.continueWithAuth', {\n            requestId: event.requestId,\n            authChallengeResponse: { response, username, password },\n        })\n            .catch(helper_js_1.debugError);\n    }\n    _onRequestPaused(event) {\n        if (!this._userRequestInterceptionEnabled &&\n            this._protocolRequestInterceptionEnabled) {\n            this._client\n                .send('Fetch.continueRequest', {\n                requestId: event.requestId,\n            })\n                .catch(helper_js_1.debugError);\n        }\n        const requestId = event.networkId;\n        const interceptionId = event.requestId;\n        if (requestId && this._requestIdToRequestWillBeSentEvent.has(requestId)) {\n            const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n            this._onRequest(requestWillBeSentEvent, interceptionId);\n            this._requestIdToRequestWillBeSentEvent.delete(requestId);\n        }\n        else {\n            this._requestIdToInterceptionId.set(requestId, interceptionId);\n        }\n    }\n    _onRequest(event, interceptionId) {\n        let redirectChain = [];\n        if (event.redirectResponse) {\n            const request = this._requestIdToRequest.get(event.requestId);\n            // If we connect late to the target, we could have missed the\n            // requestWillBeSent event.\n            if (request) {\n                this._handleRequestRedirect(request, event.redirectResponse);\n                redirectChain = request._redirectChain;\n            }\n        }\n        const frame = event.frameId\n            ? this._frameManager.frame(event.frameId)\n            : null;\n        const request = new HTTPRequest_js_1.HTTPRequest(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n        this._requestIdToRequest.set(event.requestId, request);\n        this.emit(exports.NetworkManagerEmittedEvents.Request, request);\n    }\n    _onRequestServedFromCache(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        if (request)\n            request._fromMemoryCache = true;\n    }\n    _handleRequestRedirect(request, responsePayload) {\n        const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, responsePayload);\n        request._response = response;\n        request._redirectChain.push(request);\n        response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n        this._requestIdToRequest.delete(request._requestId);\n        this._attemptedAuthentications.delete(request._interceptionId);\n        this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n        this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n    }\n    _onResponseReceived(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // FileUpload sends a response without a matching request.\n        if (!request)\n            return;\n        const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, event.response);\n        request._response = response;\n        this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n    }\n    _onLoadingFinished(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // For certain requestIds we never receive requestWillBeSent event.\n        // @see https://crbug.com/750469\n        if (!request)\n            return;\n        // Under certain conditions we never get the Network.responseReceived\n        // event from protocol. @see https://crbug.com/883475\n        if (request.response())\n            request.response()._resolveBody(null);\n        this._requestIdToRequest.delete(request._requestId);\n        this._attemptedAuthentications.delete(request._interceptionId);\n        this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n    }\n    _onLoadingFailed(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // For certain requestIds we never receive requestWillBeSent event.\n        // @see https://crbug.com/750469\n        if (!request)\n            return;\n        request._failureText = event.errorText;\n        const response = request.response();\n        if (response)\n            response._resolveBody(null);\n        this._requestIdToRequest.delete(request._requestId);\n        this._attemptedAuthentications.delete(request._interceptionId);\n        this.emit(exports.NetworkManagerEmittedEvents.RequestFailed, request);\n    }\n}\nexports.NetworkManager = NetworkManager;\n"]},"metadata":{},"sourceType":"script"}