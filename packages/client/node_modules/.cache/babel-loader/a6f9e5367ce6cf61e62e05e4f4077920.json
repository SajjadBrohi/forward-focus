{"ast":null,"code":"var fs = require('fs');\n\nvar util = require('util');\n\nvar stream = require('stream');\n\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar PassThrough = stream.PassThrough;\n\nvar Pend = require('pend');\n\nvar EventEmitter = require('events').EventEmitter;\n\nexports.createFromBuffer = createFromBuffer;\nexports.createFromFd = createFromFd;\nexports.BufferSlicer = BufferSlicer;\nexports.FdSlicer = FdSlicer;\nutil.inherits(FdSlicer, EventEmitter);\n\nfunction FdSlicer(fd, options) {\n  options = options || {};\n  EventEmitter.call(this);\n  this.fd = fd;\n  this.pend = new Pend();\n  this.pend.max = 1;\n  this.refCount = 0;\n  this.autoClose = !!options.autoClose;\n}\n\nFdSlicer.prototype.read = function (buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function (cb) {\n    fs.read(self.fd, buffer, offset, length, position, function (err, bytesRead, buffer) {\n      cb();\n      callback(err, bytesRead, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.write = function (buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function (cb) {\n    fs.write(self.fd, buffer, offset, length, position, function (err, written, buffer) {\n      cb();\n      callback(err, written, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.createReadStream = function (options) {\n  return new ReadStream(this, options);\n};\n\nFdSlicer.prototype.createWriteStream = function (options) {\n  return new WriteStream(this, options);\n};\n\nFdSlicer.prototype.ref = function () {\n  this.refCount += 1;\n};\n\nFdSlicer.prototype.unref = function () {\n  var self = this;\n  self.refCount -= 1;\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  if (self.autoClose) {\n    fs.close(self.fd, onCloseDone);\n  }\n\n  function onCloseDone(err) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      self.emit('close');\n    }\n  }\n};\n\nutil.inherits(ReadStream, Readable);\n\nfunction ReadStream(context, options) {\n  options = options || {};\n  Readable.call(this, options);\n  this.context = context;\n  this.context.ref();\n  this.start = options.start || 0;\n  this.endOffset = options.end;\n  this.pos = this.start;\n  this.destroyed = false;\n}\n\nReadStream.prototype._read = function (n) {\n  var self = this;\n  if (self.destroyed) return;\n  var toRead = Math.min(self._readableState.highWaterMark, n);\n\n  if (self.endOffset != null) {\n    toRead = Math.min(toRead, self.endOffset - self.pos);\n  }\n\n  if (toRead <= 0) {\n    self.destroyed = true;\n    self.push(null);\n    self.context.unref();\n    return;\n  }\n\n  self.context.pend.go(function (cb) {\n    if (self.destroyed) return cb();\n    var buffer = new Buffer(toRead);\n    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function (err, bytesRead) {\n      if (err) {\n        self.destroy(err);\n      } else if (bytesRead === 0) {\n        self.destroyed = true;\n        self.push(null);\n        self.context.unref();\n      } else {\n        self.pos += bytesRead;\n        self.push(buffer.slice(0, bytesRead));\n      }\n\n      cb();\n    });\n  });\n};\n\nReadStream.prototype.destroy = function (err) {\n  if (this.destroyed) return;\n  err = err || new Error(\"stream destroyed\");\n  this.destroyed = true;\n  this.emit('error', err);\n  this.context.unref();\n};\n\nutil.inherits(WriteStream, Writable);\n\nfunction WriteStream(context, options) {\n  options = options || {};\n  Writable.call(this, options);\n  this.context = context;\n  this.context.ref();\n  this.start = options.start || 0;\n  this.endOffset = options.end == null ? Infinity : +options.end;\n  this.bytesWritten = 0;\n  this.pos = this.start;\n  this.destroyed = false;\n  this.on('finish', this.destroy.bind(this));\n}\n\nWriteStream.prototype._write = function (buffer, encoding, callback) {\n  var self = this;\n  if (self.destroyed) return;\n\n  if (self.pos + buffer.length > self.endOffset) {\n    var err = new Error(\"maximum file length exceeded\");\n    err.code = 'ETOOBIG';\n    self.destroy();\n    callback(err);\n    return;\n  }\n\n  self.context.pend.go(function (cb) {\n    if (self.destroyed) return cb();\n    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function (err, bytes) {\n      if (err) {\n        self.destroy();\n        cb();\n        callback(err);\n      } else {\n        self.bytesWritten += bytes;\n        self.pos += bytes;\n        self.emit('progress');\n        cb();\n        callback();\n      }\n    });\n  });\n};\n\nWriteStream.prototype.destroy = function () {\n  if (this.destroyed) return;\n  this.destroyed = true;\n  this.context.unref();\n};\n\nutil.inherits(BufferSlicer, EventEmitter);\n\nfunction BufferSlicer(buffer, options) {\n  EventEmitter.call(this);\n  options = options || {};\n  this.refCount = 0;\n  this.buffer = buffer;\n  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;\n}\n\nBufferSlicer.prototype.read = function (buffer, offset, length, position, callback) {\n  var end = position + length;\n  var delta = end - this.buffer.length;\n  var written = delta > 0 ? delta : length;\n  this.buffer.copy(buffer, offset, position, end);\n  setImmediate(function () {\n    callback(null, written);\n  });\n};\n\nBufferSlicer.prototype.write = function (buffer, offset, length, position, callback) {\n  buffer.copy(this.buffer, position, offset, offset + length);\n  setImmediate(function () {\n    callback(null, length, buffer);\n  });\n};\n\nBufferSlicer.prototype.createReadStream = function (options) {\n  options = options || {};\n  var readStream = new PassThrough(options);\n  readStream.destroyed = false;\n  readStream.start = options.start || 0;\n  readStream.endOffset = options.end; // by the time this function returns, we'll be done.\n\n  readStream.pos = readStream.endOffset || this.buffer.length; // respect the maxChunkSize option to slice up the chunk into smaller pieces.\n\n  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);\n  var offset = 0;\n\n  while (true) {\n    var nextOffset = offset + this.maxChunkSize;\n\n    if (nextOffset >= entireSlice.length) {\n      // last chunk\n      if (offset < entireSlice.length) {\n        readStream.write(entireSlice.slice(offset, entireSlice.length));\n      }\n\n      break;\n    }\n\n    readStream.write(entireSlice.slice(offset, nextOffset));\n    offset = nextOffset;\n  }\n\n  readStream.end();\n\n  readStream.destroy = function () {\n    readStream.destroyed = true;\n  };\n\n  return readStream;\n};\n\nBufferSlicer.prototype.createWriteStream = function (options) {\n  var bufferSlicer = this;\n  options = options || {};\n  var writeStream = new Writable(options);\n  writeStream.start = options.start || 0;\n  writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;\n  writeStream.bytesWritten = 0;\n  writeStream.pos = writeStream.start;\n  writeStream.destroyed = false;\n\n  writeStream._write = function (buffer, encoding, callback) {\n    if (writeStream.destroyed) return;\n    var end = writeStream.pos + buffer.length;\n\n    if (end > writeStream.endOffset) {\n      var err = new Error(\"maximum file length exceeded\");\n      err.code = 'ETOOBIG';\n      writeStream.destroyed = true;\n      callback(err);\n      return;\n    }\n\n    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);\n    writeStream.bytesWritten += buffer.length;\n    writeStream.pos = end;\n    writeStream.emit('progress');\n    callback();\n  };\n\n  writeStream.destroy = function () {\n    writeStream.destroyed = true;\n  };\n\n  return writeStream;\n};\n\nBufferSlicer.prototype.ref = function () {\n  this.refCount += 1;\n};\n\nBufferSlicer.prototype.unref = function () {\n  this.refCount -= 1;\n\n  if (this.refCount < 0) {\n    throw new Error(\"invalid unref\");\n  }\n};\n\nfunction createFromBuffer(buffer, options) {\n  return new BufferSlicer(buffer, options);\n}\n\nfunction createFromFd(fd, options) {\n  return new FdSlicer(fd, options);\n}","map":{"version":3,"sources":["C:/Users/Sajjad Brohi/JavaScript Projects/RESTful API/packages/client/node_modules/fd-slicer/index.js"],"names":["fs","require","util","stream","Readable","Writable","PassThrough","Pend","EventEmitter","exports","createFromBuffer","createFromFd","BufferSlicer","FdSlicer","inherits","fd","options","call","pend","max","refCount","autoClose","prototype","read","buffer","offset","length","position","callback","self","go","cb","err","bytesRead","write","written","createReadStream","ReadStream","createWriteStream","WriteStream","ref","unref","Error","close","onCloseDone","emit","context","start","endOffset","end","pos","destroyed","_read","n","toRead","Math","min","_readableState","highWaterMark","push","Buffer","destroy","slice","Infinity","bytesWritten","on","bind","_write","encoding","code","bytes","maxChunkSize","Number","MAX_SAFE_INTEGER","delta","copy","setImmediate","readStream","entireSlice","nextOffset","bufferSlicer","writeStream"],"mappings":"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","sourcesContent":["var fs = require('fs');\nvar util = require('util');\nvar stream = require('stream');\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar PassThrough = stream.PassThrough;\nvar Pend = require('pend');\nvar EventEmitter = require('events').EventEmitter;\n\nexports.createFromBuffer = createFromBuffer;\nexports.createFromFd = createFromFd;\nexports.BufferSlicer = BufferSlicer;\nexports.FdSlicer = FdSlicer;\n\nutil.inherits(FdSlicer, EventEmitter);\nfunction FdSlicer(fd, options) {\n  options = options || {};\n  EventEmitter.call(this);\n\n  this.fd = fd;\n  this.pend = new Pend();\n  this.pend.max = 1;\n  this.refCount = 0;\n  this.autoClose = !!options.autoClose;\n}\n\nFdSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {\n      cb();\n      callback(err, bytesRead, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {\n      cb();\n      callback(err, written, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.createReadStream = function(options) {\n  return new ReadStream(this, options);\n};\n\nFdSlicer.prototype.createWriteStream = function(options) {\n  return new WriteStream(this, options);\n};\n\nFdSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nFdSlicer.prototype.unref = function() {\n  var self = this;\n  self.refCount -= 1;\n\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  if (self.autoClose) {\n    fs.close(self.fd, onCloseDone);\n  }\n\n  function onCloseDone(err) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      self.emit('close');\n    }\n  }\n};\n\nutil.inherits(ReadStream, Readable);\nfunction ReadStream(context, options) {\n  options = options || {};\n  Readable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = options.end;\n  this.pos = this.start;\n  this.destroyed = false;\n}\n\nReadStream.prototype._read = function(n) {\n  var self = this;\n  if (self.destroyed) return;\n\n  var toRead = Math.min(self._readableState.highWaterMark, n);\n  if (self.endOffset != null) {\n    toRead = Math.min(toRead, self.endOffset - self.pos);\n  }\n  if (toRead <= 0) {\n    self.destroyed = true;\n    self.push(null);\n    self.context.unref();\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    var buffer = new Buffer(toRead);\n    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {\n      if (err) {\n        self.destroy(err);\n      } else if (bytesRead === 0) {\n        self.destroyed = true;\n        self.push(null);\n        self.context.unref();\n      } else {\n        self.pos += bytesRead;\n        self.push(buffer.slice(0, bytesRead));\n      }\n      cb();\n    });\n  });\n};\n\nReadStream.prototype.destroy = function(err) {\n  if (this.destroyed) return;\n  err = err || new Error(\"stream destroyed\");\n  this.destroyed = true;\n  this.emit('error', err);\n  this.context.unref();\n};\n\nutil.inherits(WriteStream, Writable);\nfunction WriteStream(context, options) {\n  options = options || {};\n  Writable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = (options.end == null) ? Infinity : +options.end;\n  this.bytesWritten = 0;\n  this.pos = this.start;\n  this.destroyed = false;\n\n  this.on('finish', this.destroy.bind(this));\n}\n\nWriteStream.prototype._write = function(buffer, encoding, callback) {\n  var self = this;\n  if (self.destroyed) return;\n\n  if (self.pos + buffer.length > self.endOffset) {\n    var err = new Error(\"maximum file length exceeded\");\n    err.code = 'ETOOBIG';\n    self.destroy();\n    callback(err);\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {\n      if (err) {\n        self.destroy();\n        cb();\n        callback(err);\n      } else {\n        self.bytesWritten += bytes;\n        self.pos += bytes;\n        self.emit('progress');\n        cb();\n        callback();\n      }\n    });\n  });\n};\n\nWriteStream.prototype.destroy = function() {\n  if (this.destroyed) return;\n  this.destroyed = true;\n  this.context.unref();\n};\n\nutil.inherits(BufferSlicer, EventEmitter);\nfunction BufferSlicer(buffer, options) {\n  EventEmitter.call(this);\n\n  options = options || {};\n  this.refCount = 0;\n  this.buffer = buffer;\n  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;\n}\n\nBufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var end = position + length;\n  var delta = end - this.buffer.length;\n  var written = (delta > 0) ? delta : length;\n  this.buffer.copy(buffer, offset, position, end);\n  setImmediate(function() {\n    callback(null, written);\n  });\n};\n\nBufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  buffer.copy(this.buffer, position, offset, offset + length);\n  setImmediate(function() {\n    callback(null, length, buffer);\n  });\n};\n\nBufferSlicer.prototype.createReadStream = function(options) {\n  options = options || {};\n  var readStream = new PassThrough(options);\n  readStream.destroyed = false;\n  readStream.start = options.start || 0;\n  readStream.endOffset = options.end;\n  // by the time this function returns, we'll be done.\n  readStream.pos = readStream.endOffset || this.buffer.length;\n\n  // respect the maxChunkSize option to slice up the chunk into smaller pieces.\n  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);\n  var offset = 0;\n  while (true) {\n    var nextOffset = offset + this.maxChunkSize;\n    if (nextOffset >= entireSlice.length) {\n      // last chunk\n      if (offset < entireSlice.length) {\n        readStream.write(entireSlice.slice(offset, entireSlice.length));\n      }\n      break;\n    }\n    readStream.write(entireSlice.slice(offset, nextOffset));\n    offset = nextOffset;\n  }\n\n  readStream.end();\n  readStream.destroy = function() {\n    readStream.destroyed = true;\n  };\n  return readStream;\n};\n\nBufferSlicer.prototype.createWriteStream = function(options) {\n  var bufferSlicer = this;\n  options = options || {};\n  var writeStream = new Writable(options);\n  writeStream.start = options.start || 0;\n  writeStream.endOffset = (options.end == null) ? this.buffer.length : +options.end;\n  writeStream.bytesWritten = 0;\n  writeStream.pos = writeStream.start;\n  writeStream.destroyed = false;\n  writeStream._write = function(buffer, encoding, callback) {\n    if (writeStream.destroyed) return;\n\n    var end = writeStream.pos + buffer.length;\n    if (end > writeStream.endOffset) {\n      var err = new Error(\"maximum file length exceeded\");\n      err.code = 'ETOOBIG';\n      writeStream.destroyed = true;\n      callback(err);\n      return;\n    }\n    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);\n\n    writeStream.bytesWritten += buffer.length;\n    writeStream.pos = end;\n    writeStream.emit('progress');\n    callback();\n  };\n  writeStream.destroy = function() {\n    writeStream.destroyed = true;\n  };\n  return writeStream;\n};\n\nBufferSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nBufferSlicer.prototype.unref = function() {\n  this.refCount -= 1;\n\n  if (this.refCount < 0) {\n    throw new Error(\"invalid unref\");\n  }\n};\n\nfunction createFromBuffer(buffer, options) {\n  return new BufferSlicer(buffer, options);\n}\n\nfunction createFromFd(fd, options) {\n  return new FdSlicer(fd, options);\n}\n"]},"metadata":{},"sourceType":"script"}